[{"title":"MySQL03-数据操作之增删改","url":"/2024/01/29/MySQL03-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E4%B9%8B%E5%A2%9E%E5%88%A0%E6%94%B9/","content":"1. insert 数据插入-DMLinsert 语句用于向数据库中插入新的数据。\n1.1 单行数据插入用 insert 语句进行单行数据插入时，每个字段与其值是严格一一对应的，即每个值、值的顺序、值的类型必须与对应的字段相匹配。其语法如下：\ninsert into 表名 [(字段1,字段2 ...)] values (值1,值2 ...);# 示例，在 student 表中插入数据insert into student (id,name,age,sex) values (1,&#x27;张三&#x27;,16,&#x27;男&#x27;);\n\n注意：\n\n需要插入空值或碰到自增字段时，用 NULL 表示数据值；\n插入语句中的各字段与其在表中定义的顺序、数量无需一致，只要与 VALUES 中值的顺序、数量相互匹配即可，也即可以让字段缺省实现部分数据插入；\n当插入数据的顺序、数量与数据表中字段的顺序、数量一致时，参数 (字段1,字段2,...) 可以缺省不写；\n使用 insert 插入语句时，要求插入的值与相应字段在数量和类型上完全匹配，否则插入操作失败；\n使用 insert 插入语句时，除了需要正确的语法，还要求插入操作与数据表上的约束不冲突，否则正确的语法也可能插入失败；\n字符串和日期型数据应该包含在引号中；\n插入的数据大小，应该在字段的规定范围内。\n\n1.2 多行数据插入用 insert 语法进行多行数据插入，语法规则和单行数据一样，各数据值用 , 连接。其语法如下：\ninsert into 表名 [(字段1,字段2,字段3 ...)]values (值11,值12,值13 ...),(值21,值22,值23 ...),(值31,值32,值33 ...);# 示例，在 student 表中插入数据insert into student (id,name,age,sex)values (0001,&#x27;张三&#x27;,16,&#x27;男&#x27;),(0002,&#x27;李四&#x27;,17,&#x27;男&#x27;),(0003,&#x27;王二麻子&#x27;,18,&#x27;女&#x27;);\n\n2. update 数据更新-DMLupdate 语句用于更新数据表中已经存在的数据记录。\n2.1 简单更新用 insert 语句进行数据插入的语法如下：\nupdate 表名set 字段名1 = 新值1, 字段名2 = 新值2[where 条件表达式];# 示例，在 student 表中 name 字段为 张三 的 数据行中，更改 age 字段为 20 ，sex 字段为 男update studentset age=20,sex=&#x27;男&#x27;where name=&#x27;张三&#x27;;\n\n其中，参数 字段名1 = 新值1/条件表达式 表示将要更新的数据，其中的新值既可以是具体值，也可以是表达式，参数 where 条件表达式 表示将要更新的数据所在位置。\n注意：\n\n用 insert 语句进行简单更新时，参数 where 条件表达式 是可选项，该参数省略时则说明更新指定字段的所有行的值；\n使用 update 语句时，即使语法正确，如果操作的数据与其他表之间存在外键关系，更新操作也可能受限，或者需要设置级联更新，在实际操作中，一条存在外键的主键记录是不能被删除或修改的；\n\n2.2 级联更新级联更新是指更新父表主键值时，所有子表外键值自动与父表主键值匹配更新的现象，外键约束中，update 语句有如下四种属性：\n\nCASCADE，级联操作属性：如果从父表中更新某个记录，首先检查该记录主键是否有对应外键，如果有则一并更新外键所在子表中的记录；\nNO ACTION &#x2F; RESTRICT，限制操作属性：在 MySQL 中两者等价，如果在父表中更新某个记录，首先检查该记录主键是否有对应外键，如果有则不允许更新，NO ACTION 来自标准的 SQL；\nSET NULL，设置空值属性：如果在父表中更新某个记录，首先检查该记录主键是否有对应外键，如果有则设置子表中该外键值为空值(NULL)，这要求定义子表时该外键允许取空值（不为非空约束）；\n\n要想设置级联更新，应该设置外键约束 update 属性为 CASCADE。\n实现级联更新操作一般分为三个步骤：\n\n检查子表的外键约束，并将其设置为级联更新属性；\n检查主表及子表是否有相同信息记录；\n如果有则从主表更新目标记录，子表即可由系统自动更新相应记录；\n\n3. delete 数据删除-DMLdelete 语句用于删除数据表的一行数据或者多行数据，甚至所有数据。\n3.1 简单删除用 delete 语句进行数据删除的语法如下：\ndelete from 表名[where 条件表达式][order by 字段名 [asc / desc]];[limit 行数]# 示例，删除 student 表中 age 字段值为 14 的所有数据行delete from studentwhere age=14;\n\n其中，参数 where 条件表达式 表示将要更新的数据所在位置；参数 order by 字段名 [asc / desc] 表示按照指定的顺序进行删除操作，asc 为升序（数值从小到大），desc 为降序（数值从大到小）；参数 limit 行数 用于告知服务器所限制删除的行数；order by 子句要和 limit 子句配合使用。\n注意：\n\n用 delete 语句进行简单删除时，参数 where 条件表达式 是可选项，该参数省略时则说明删除指定字段的所有数据行；\n删除带有空值的数据行，where语句应写为 where 字段名 is null，如删除score字段为空值的数据行：where score is null ；\ndelete 语句不能删除某一个字段的值（可以使用 update 将数据更新为空值变相实现）；\n使用 delete 语句时，即使语法正确，如果操作的数据与其他表之间存在外键关系，更新操作也可能受限，或者需要设置级联更新，在实际操作中，一条存在外键的主键记录是不能被删除或修改的；\n\n3.2 级联删除级联删除是指删除父表主键值时，所有子表外键值自动与父表主键值匹配删除的现象，外键约束中，delete 语句有如下四种属性：\n\nCASCADE，级联操作属性：如果从父表中删除某个记录，首先检查该记录主键是否有对应外键，如果有则一并删除外键所在子表中的记录；\nNO ACTION &#x2F; RESTRICT，限制操作属性：在 MySQL 中两者等价，如果在父表中删除某个记录，首先检查该记录主键是否有对应外键，如果有则不允许删除，NO ACTION 来自标准的 SQL；\nSET NULL，设置空值属性：如果在父表中删除某个记录，首先检查该记录主键是否有对应外键，如果有则设置子表中该外键值为空值(NULL)，这要求定义子表时该外键允许取空值（不为非空约束）；\n\n要想设置级联删除，应该设置外键约束 delete 属性为 CASCADE。\n实现级联删除操作一般分为三个步骤：\n\n检查子表的外键约束，并将其设置为级联删除属性；\n检查主表及子表是否有相同信息记录；\n如果有则从主表删除目标记录，子表即可由系统自动删除相应记录；\n\n3.3 删除风险等级DELETE 数据删除操作从语法来看比较简单，但因为删除操作会从当前数据库中清除数据，所以说是一种有风险的操作。删除操作有三个风险等级，具体如下：\n\n删除数据表\n\nDROP TABLE 表名;\n\n该语句用于从数据库中删除已存在的数据表，包括数据表结构，且不可恢复，因此在使用时需特别小心。这是危险级别最高的删除命令，属于 DDL（数据定义语言）。\n\n不可恢复的删除操作\n\nTRUNCATE TABLE 表名;\n\n该语句只能用于将数据表内全部数据删除，但空表结构不会被删除，因 TRUNCATE 删除操作后不记录 MySQL 日志，同样不可以恢复数据。这是危险级别次之的删除命令。\n\n有条件恢复的删除操作\n\nDELETE FROM table 表名WHERE condition;\n\n这是在特定条件下可恢复的删除操作，DELETE 语句会根据用户需求删除数据表内部分或全部数据记录，与 TRUNCATE 操作不同的是DELETE 操作记录 MySQL 日志，能有条件地实现数据回滚恢复。但从数据删除效率来说TRUNCATE 操作优于 DELETE 操作。\n注意：\n\nDELETE 语句后可跟 WHERE 子句，可通过指定WHERE子句中的条件表达式只删除满足条件的部分记录，TRUNCATE 语句则不能跟 WHERE 子句，因此只能用于删除表中的所有记录；\n使用 TRUNCATE 语句删除表中的数据后，再次向表中添加记录时自动增加字段的默认初始值重新由1开始；使用 DELETE 语句删除表中所有记录后，再次向表中添加记录时自动增加字段的值为删除时该字段的最大值加1；\nDELETE语句是DML语句，TRUNCATE语句通常被认为是DDL语句；\n无论哪种删除操作都存在数据丢失的风险，所以在实际应用场景中执行删除命令是需要相应权限的；\n\n","categories":["MySQL学习笔记"],"tags":["MySQL","学习笔记"]},{"title":"MySQL02-数据库操作","url":"/2024/01/29/MySQL02-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/","content":"1. 数据库服务的启动和连接以下有关数据库服务的启动和连接操作均以 MySQL80 为例。\n1.1 启动数据库服务器数据库服务器默认是开机自启的，也就是说一般情况下不需要手动启动数据库服务器。\n方法一：Win + R 打开运行窗口，输入 services.msc 并回车，进入 服务页面，找到列表中的 MySQL80 服务，右键选择 启动 或 停止 即可。\n方法二：以管理员身份运行（必须以管理员身份运行）cmd 命令行程序，在程序中输入以下命令即可实现相应 启动 或 停止。\n# 启动 MySQL 服务：net start mysql80# 停止 MySQL 服务：net stop mysql80\n\n1.2 连接数据库服务器方法一：在数据库程序中找到名为 MySQL 8.0 Command Line Client 的程序，双击启动后输入密码即可。\n方法二：打开 cmd 命令行程序，在程序中输入以下命令即可实现连接数据库服务器。\nmysql -u root -p\n\n其中 -u 表示数据库用户名，root 是 MySQL 的默认用户名，根据自身情况修改即可，-p 表示数据库密码，数据库密码应在输入以上命令回车后再输入，如果在 -p 之后写入了内容，MySQL将把他识别为连接数据库服务器后进入的数据库名称，比如如果输入的是 mysql -u root -p student，就表示连接数据库服务器后直接进入数据库 student，也即省略了 use student 一步。\n2. 数据库操作-DDL2.1 创建数据库create database [if not exists] 数据库名 [character set 字符集] [collate 校对规则];# []内的内容为可选值，其简洁写法如下：create database 数据库名;# 如，创建数据库 students，设置字符集为 utf8mb4，设定该数据库不存在才创建，负责不执行语句：create database if not exists students character set utf8mb4;\n\n说明：\n\n数据库名：即数据库的名称，MySQL的数据存储区将以目录方式表示MySQL数据库，因此数据库名称必须符合操作系统的文件夹命名规则，不能以数字开头，尽量要有实际意义，在MySQL中不区分大小写；\nIF NOT EXISTS：在创建数据库之前进行判断，只有该数据库目前尚不存在时才能执行操作。此选项可以用来避免数据库已经存在而重复创建的错误；\nCHARACTER SET 字符集：也写作 default charset 字符集 ，指定数据库的字符集，指定字符集的目的是为了避免在数据库中存储的数据出现乱码的情况，如果在创建数据库时不指定字符集，那么就使用系统的默认（default）字符集，UTF8字符集长度为 3 字节，有些符号占 4 字节，所以推荐用 utf8mb4 字符集；\nCOLLATE 校对规则：指定字符集的默认校对规则，校对规则定义了比较字符串的方式；\n\n2.2 使用数据库use 数据库名;# 有没有分号 ; 都可以\n\nuse 语句不仅可以使用数据库，还能 选择 或 切换 数据库。\n2.3 查询数据库\n查询所有数据库（名称）\n\nshow databases;\n\n\n查询当前数据库（名称）\n\nselect database();\n\n\n查询指定数据库的建库语句\n\nshow create database 数据库名;\n\n这里的表是指已经建好的数据库，使用 show create database 数据库名; 语句可以查看创建该数据库的过程\n\n查看数据库基本信息\n\nshow create database 数据库名;\n\n2.4 删除数据库drop database [if exists] 数据库名;\n\n说明：IF EXISTS：在删除数据库之前进行判断，只有该数据库存在时才执行删除操作。\n2.5 修改数据库修改数据库字符集\nalter database 数据库名 character set 字符集;\n\n3. 表操作-DDL进行所有的表操作之前都要使用 use 数据库名; 语法进入数据库。\n3.1 创建表create table 表名 \t(\t字段1 字段1类型,\t字段2 字段2类型,\t字段3 字段3类型,\t...\t字段n 字段n类型\t);\n\n创建表的语法中每个字段以 , 分隔，但最后一个字段后面没有逗号创建表或字段的语句后可以使用 comment 注释 语句添加注释，如以上语法可以写为：\ncreate table 表名 (字段1 字段1类型 [comment 字段1注释],字段2 字段2类型 [comment 字段2注释])[comment 表注释];\n\n3.2 查询表\n查询当前数据库所有表\n\nshow tables;\n\n\n查询表结构\n\ndescribe 表名;# 或简写desc 表名;\n\n\n查询指定表的建表语句\n\nshow create table 表名;\n\n这里的表是指已经建好的表，使用 show create table 表名; 语句可以查看创建该表的过程\n3.3 修改表\n修改表名\n\nalter table 表名 rename to 新表名\n\n\n添加字段\n\nalter table 表名 add 字段名 数据类型(数据长度) [comment 注释] [约束];# 如，在 students 表中添加 stuname 字段，数据类型为 varchar(20)：alter table students ADD stuname varchar(20) comment &#x27;注释&#x27;;\n\n\n删除字段\n\nalter table 表名 drop 字段名;\n\n\n修改字段数据类型\n\nalter table 表名 modify 字段名 新数据类型(数据长度);# 如，将 students 表的 stuname 字段数据类型修改为 varchar(30)：alter table students modify stuname varchar(30);\n\n\n修改字段名和字段数据类型\n\nalter table 表名 change 旧字段名 新字段名 数据类型(数据长度) [comment 注释];# 如，将 students 表的 stuname 字段名修改为 stuname01，类型为 varchar(30)：alter table students change stuname stuname01 varchar(30) comment &#x27;昵称&#x27;;\n\n3.4 删除表\n删除表\n\ndrop table [if exists] 表名;\n\n\n删除表并重新创建该表，会保留原表结构，但清除原表数据\n\ntruncate table 表名;","categories":["MySQL学习笔记"],"tags":["MySQL","学习笔记"]},{"title":"MySQL04-数据操作之单表查询&别名","url":"/2024/01/29/MySQL04-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E4%B9%8B%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2&%E5%88%AB%E5%90%8D/","content":"1. 别名别名就是一个字符串标识，使用别名可以让数据展示更加直观。\n1.1 表的别名在查询操作，特别是多表查询操作时，假若表名很长使用起来就不太方便，此时可为表取一个別名，用该别名来代替表的名称。其语法格式如下：\n表名 [as] 表的别名 # 其中，as 可以省略，如：表名 表的别名# 例如，将 student 改为 stu 查询整表select * from student as stu;\n\n1.2 字段的别名为字段取别名的语法格式如下：\n字段名 [as] 字段的别名# 或字段名 字段的别名# 例如，将 student 中的 name 取别名为“姓名”，age 取别名为 “年龄”，查询整表select name as &#x27;姓名&#x27;,age as &#x27;年龄&#x27;from student;\n\n注意：\n\n别名字符串一般可以不加引号，但如果别名内有空格，则必须用单引号或双引号引起来；\n字段名与别名之间也可以不用 as ，而直接用空格连接，如：select name 姓名,age 年龄 from student; ；\n在 select 语句执行中，where 子句执行顺序在前，列别名生效在后，因此在 where 子句中不能用别名来判断，必须用列的原名判断，否则运行会报错；\n\n2. 简单查询-DQLselect 语句用于从表中选取数据，并将结果存储在结果表中，这个结果表也常常称为结果集。\n2.1 单字段&#x2F;多字段查询select 字段1,字段2,字段3...from 表名;# 示例，从 student 表中查询 name、age 字段select name,agefrom student;# 示例，用通配符 * 从 student 表中查询所有字段select * from 表名;\n\n说明：\n\n如果查询的是表中的所有字段，可以使用通配符 * 代替字段名，查询语句可以写成：select * from 表名;，表示查询该表的所有字段内容，即按照创建表时的顺序排列展示所有字段，在实际应用中不建议使用 select * 语句，这会降低数据查询效率；\n\n2.2 去除重复记录查询去除重复记录查询即将查询结果中的重复值合并，通常用于只需知道整体分布情况，不需精确到个人的情况下，比如查询学生家庭住址分布情况、学生年龄分布情况等。\nselect distinct 字段1,字段2,字段3...from 表名;\n\n注意：\n\n在 select 中除了书写列名，还可以书写字符串，这样书写可以用于标记，如查询日期标记字段： select stuid, stuname,&#39;2023-03-20&#39; from student;，可以在查询结果中 stuid 和 stuname 字段后加一个 2023-03-20 字段，用于标记日期。\n\n3. 条件查询-DQL在简单查询的基础上加上 where 子句，即可实现条件查询，其基本语法如下：\nselect 字段名1,字段名2... from 表名 [where 条件表达式];\n\n根据 where 子句的条件表达式不同，条件查询又可分为以下几种不同的类型\n3.1 关系运算符查询使用关系运算符构成 where 子句的条件表达式，可完成一类条件查询，MySQL中常用的关系运算符有：\n\n\n\n关系运算符\n说明\n\n\n\n= 或 &lt;=&gt;\n等于\n\n\n&lt;&gt; 或 !=\n不等于\n\n\n&lt;\n小于\n\n\n!&lt;\n不小于\n\n\n&lt;=\n小于等于\n\n\n&gt;\n大于\n\n\n!&gt;\n不大于\n\n\n&gt;=\n大于等于\n\n\n例如，查询 student 表中年龄等于或大于17的学生的信息：\nselect *from studentwhere age &gt;= 17;\n\n注意：\n\n= 和 &lt;=&gt; 几乎完全相同，区别在于 &lt;=&gt; 可以用来对 NULL 进行判断，被比较的两者都为 NULL 时，返回值为 1，即逻辑真；\n&lt;&gt; 和 != 是完全等价的，都是进行不等于判断；\n\n3.2 between and 关键字查询between and 关键字用于判断某个字段的值是否在指定的范围之内，是SQL中专门关于闭区间判断的运算符，其基本语法如下：\nselect 字段1,字段2...from 表名where 字段名 between 值1 and 值2;# 例如，查询 student 表中字段 score 在 60 - 85 之间的学生的信息select *from studentwhere score between 60 and 85;# 同时，between and 关键字 也可用关系运算符表示，即上述示例可表示为select *from studentwhere score &gt;= 60 and score &lt;= 85;\n\n注意：\n\nbetween 之后跟的是范围的最小值，and 之后跟的是范围的最大值，两者顺序不能颠倒；\nnot between and 是 between and 运算的反运算，其格式为在 between and 运算前直接加 not，如：\n\n# 查询 student 表中字段 score 在 60 - 85 以外的学生的信息select *from studentwhere score not between 60 and 85;\n\n3.3 like 关键字和通配符查询like 关键字用于判断两个字符串是否相匹配，可直接匹配字符串，也可配合通配符 % 或 _ 进行模糊查询，其基本语法如下：\nselect 字段1,字段2...from 表名where 字段名 like 通配符表示的值;# like 直接匹配字符串查询，查询 student 表中字段 name 为 陈 的学生的信息select *from studentwhere name like &#x27;陈&#x27;;# like 配合通配符进行模糊查询，查询 student 表中字段 name 姓为 陈 的学生的信息select *from studentwhere name like &#x27;陈%&#x27;;\n\n注意：\n\nnot like 是 like 运算的反运算，其格式为在 like 运算前直接加 not，如：\n\n# 查询 student 表中字段 name 姓不为 陈 的学生的信息select *from studentwhere name not like &#x27;陈%&#x27;;\n\n通配符的转义\n转义即表示转义字符原来的语义，一个转义字符的目的是开始一个字符序列，使得转义字符开头的该字符序列具有不同于该字符序列单独出现时的语义。\nselect *from 表名where 条件表达式escape &#x27;/&#x27;;# 示例，查询名字里带有_的人select *from studentwhere name like &#x27;/_%&#x27;escape &#x27;/&#x27;;\n\n如上所述，原先 _ 在MySQL中表示通配符，表示匹配一个字符，当要查询包含 _ 的字段时，就需要用 / 对 _ 进行转义，取消它的通配符资格，也即 /_ 等同于字符 _ ；escape 关键字的主要作用就是指定任意一个字符替代 / 的作用。\n3.4 and 关键字查询and 关键字，也即逻辑与，表示并且，用来关联两个或两个以上的条件，用 and 连接的条件需同时成立，其基本语法如下：\nselect 字段1,字段2...from 表名where 条件表达式1 and 条件表达式2;# 例如，查询 student 表中 age 大于 15 且 sex 为 男 的学生信息select *from studentwhere age &gt; 15 and sex = &#x27;男&#x27;;\n\n注意：\n\n因为 and 关键字表示并且，在同一记录（同一行）中，不存在一个字段是 A 并且同时是 B 的情况（比如字段 sex，不能既是男又是女），所以用 and 关键字连接的条件字段名应不相同，就像上面例子中的字段 age 和 sex，一定得是两个不同的字段名，如果一个查询的两个条件是属于同一字段的，那就不应该是逻辑与，而是逻辑或，即应该使用 or 关键字查询，这也是判断使用 and 或 or 关键字的方法；\nand 关键字也可用符号 &amp;&amp; 表示，比如上面的例子可以写成 select * from student where age &gt; 15 &amp;&amp; sex = &#39;男&#39;;，但是并不常用，日常使用写作 and 为好。\n\n3.5 or 关键字查询or 关键字，也即逻辑或，表示或者，用来关联两个或两个以上的条件，用 or 连接的条件只要满足其中任意一个即可，其基本语法如下：\nselect 字段1,字段2...from 表名where 条件表达式1 or 条件表达式2;# 例如，查询 student 表中字段 addr 为新疆或西藏的学生的信息select *from studentwhere addr = 新疆 or addr = 西藏;\n\n注意：\n\nAND(与) 和 OR(或) 运算是有优先级的，AND 的优先级要高于 OR；\n在同时有 AND 和 OR 的运算中，要使 OR 运算优先运行，可以用小括号 () 把 OR 连接的条件括起来，小括号的优先级是最高的；\nor 关键字也可用符号 || 表示，比如上面的例子可以写成 select * from student where addr = 新疆 || addr = 西藏;，但是并不常用，日常使用写作 or 为好。\n\n3.6 in 关键字查询in 关键字用于判断某个字段的值是否在指定集合中（两个或两个以上同一字段的条件时），其基本语法如下：\nselect 字段1,字段2...from 表名where 字段名 in (值1,值2...);# 例如，查询 student 表中字段 addr 为新疆、西藏的学生的信息select *from studentwhere addr in (&#x27;新疆&#x27;,&#x27;西藏&#x27;);\n\n注意：\n\nin 关键字和 and 关键字大体上是一样的，不同在于，当多个条件所在的字段不同时，只能用 and 关键字，当多个条件所在的字段相同时，使用 in 关键字写法更简洁；\nnot in 为不包含运算，是 in 运算的反运算，其格式为在 in 运算前直接加 not，如：\n\n# 查询 student 表中字段 addr 为新疆、西藏之外的学生的信息select *from studentwhere addr not in (&#x27;新疆&#x27;,&#x27;西藏&#x27;);\n\n3.7 null 值查询在MySQL中，使用 IS NULL 关键字来判断字段的值是否为空值 NULL，其基本语法如下：\nselect 字段1,字段2...from 表名where 字段名 is null;# 例如，查询 student 表中字段 score 为 null 的学生的信息select *from studentwhere score is null;\n\n注意：\n\nNULL 值是数据库中一个非常特殊的值，叫空值，它不是数值中的 0，也不是字符中的空格或空字符串，NULL 是 a missing unknownvalue，即不存在、不确定的意思；\n要判断 NULL 值，必须有专门的比较运算符或函数，IS NULL 就是用于判断空值 NULL 是函数；\n因为 is null 是一种函数，所以 字段名 is null 等同于 is null (字段名) ，两者效果一样；\nIS NULL 专门用来判断空值，不能用 = null 表示，而是等同于 &lt;=&gt; null ，仅能用 &lt;=&gt; 判断NULL，这也是 = 和 &lt;=&gt; 的区别；\nis not null 是 is null 运算的反运算，其格式为在 is null 运算间直接加 not，如：\n\n# 查询 student 表中字段 score 不为 null 的学生的信息select *from studentwhere score is not null;\n\n4. 统计查询-DQL4.1 聚合函数查询聚合统计函数也叫组函数、聚簇函数，与数学函数、字符串函数等不同，聚合函数只作用于表中的某一字段（某一列），在默认情况下，聚合函数会把当前表中的数据当做一个组进行统计，聚合函数有以下几种类型：\ncount()：计数函数，统计表的行数或某个列下值的个数。max()：最大值函数，求某列值中的最大值。min()：最小值函数，求某列值中的最小值。sum()：求和函数，对表的某列进行求和操作，显然这个列只能是数值类型列，否则报错。avg()：平均值函数，对表的某列进行求平均值操作，显然这个列也只能是数值类型列，否则报错。\n聚合函数的使用语法如下：\nselect 聚合函数(字段1,字段2,字段3...) from 表名;# 使用 count() 函数统计 student 表中学生人数select count(*) from student;# 使用 max() 函数查询 student 表中最大年龄select max(stuage) from student;# 使用 min() 函数查询 student 表中最小年龄select min(stuage) from student;# 使用 sum() 函数查询 student 表中年龄和select sum(stuage) from student;# 使用 avg() 函数查询 student 表中年龄平均值select avg(stuage) from student;\n\n注意：\n\n聚合函数具有自动滤空的功能，若字段中某一个值为NULL，那么会自动将其过滤使其不参与运算；\n使用 count() 函数统计时，如果统计的字段没有空值，则可以写为 count(任一字段名) 或 count(*)，两种写法效果一样；\n\n4.2 group by 分组查询group by 子句会先将表中的数据进行分组，再进行查询等操作，可理解为将原来的表拆分成了几张小表，其基本语法如下：\nselect 字段1,字段2...from 表名group by 字段3,字段4...# 例如，统计 student 表中男女生年龄平均值select stusex 性别, avg(stuage) 平均年龄from studentgroup by stusex;# 即以 stusex 为分组依据，查询 student 表中 stusex 和 avg(stuage) 两个字段\n\n注意：\n\ngroup by 子句后可跟多个字段，即多级分组，在多级分组时，一级分组内有重复数据，二级分组才会有意义，以此类推，同时多个字段的顺序直接控制了数据源中数据的分组方式，即从前往后依次为一级、二级、三级……分组，这类似于 Excel 中的多级排序；\n\n# 例如，统计 student 表中各地男女生人数select addr 地址, stusex 性别, count(stuid) 人数from studentgroup by addr,stusex;# 这里先以学生住址分组，同时，在同一住址中都有男女生，再在住址分组的基础上以男女生分组\n\n\n在具体应用中，group by 子句常与聚合函数一起使用；\n在分组查询中，查询的字段（select 后跟着的字段）一般为聚合函数和分组字段，查询其他字段是没有意义的；\n一般在 select 语句中加入 group by 子句的分组依据列，以提高查询结果集的可读性；\n\n4.3 having 统计限制having 子句以来实现对分组统计的条件限制，与 where 子句的条件限制功能有些相似，但 having 子句是对 group by 分组后的结果进行过滤，只能出现在 group by 子句之后，其基本语法如下：\nselect 字段1,字段2...from 表名group by 字段3,字段4...having 条件表达式# 例如，统计 score 表中平均分高于 80 的学生的学号和平均分select stuid 学号,avg(score) 平均分from scoregroup by stuidhaving 平均分 &gt; 80;\n\n注意：\n\nselect 语句的各子句的相对位置不能前后颠倒，group by 子句只能在 where 子句后面，having 子句只能在 group by 子句后面；\n在查询中，SQL的执行顺序为 FROM -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT；\n\nwhere 子句和 having 子句的区别：\n\n使用位置不同，where 子句通常出现在 select 语句的最后面，having 子句通常出现在 group by 子句之后；\n执行时机不同，where 子句在 group by 子句之前对数据进行筛选，having 子句对 group by 子句之后得到的数据进行过滤；\n判断条件不同，where 子句的条件中不能包含聚合函数，having 子句中不能使用除了分组字段（即 group by 子句后跟着的字段）和聚合函数之外的其他字段；\n过滤对象不同，where 子句用于过滤从数据表中检索的行，它可以用于过滤行的任何条件，如等于、小于、大于等，而 having 子句用于过滤聚合函数的结果，如 SUM、AVG、COUNT 等，它通常用于过滤分组后的结果。\n对性能的影响不同，where 子句在过滤数据时，可以减少查询的数据量，从而提高查询的效率。而 having 子句则是在过滤分组后的结果时进行过滤，如果使用不当，可能会对查询的性能造成负面影响。从性能的角度来说，having 子句中如果使用了分组字段作为过滤条件，应该替换成 where 子句；因为 where 子句可以在执行分组操作和计算聚合函数之前过滤掉不需要的数据，性能会更好；\n\n5. 排序查询-DQL通过 select 语句查询的默认查询结果集中，数据是按照数据记录的物理顺序来显示的，当默认的查询结果顺序无法满足需求时，可通过添加 order by 子句来控制查询结果的顺序。\n5.1 order by 排序查询order by 子句用来对查询结果集进行排序，排序依据即其后指定的字段，排序方式由 asc 或 desc 控制，其基本语法如下：\nselect 字段1,字段2...from 表名order by 字段3,字段4...# 例如，查询 score 表中的学号及分数，并按分数高低降序排列select stuid,scorefrom scoreorder by score desc;\n\n注意：\n\norder by 子句中，asc 为升序（数值从小到大），desc 为降序（数值从大到小），排序方式在缺省状态下默认为升序 asc；\n若 order by 子句后跟着多个字段，即指定了多个排序依据，产生多级排序，从前往后依次为一级、二级、三级……排序，同时，各个排序依据还能指定不同的排序方式，如 order by score desc,stuid asc，但要注意，在多级排序时，一级排序内有重复数据，二级排序才会有意义，以此类推；\n\n# 例如，查询 score 表中的学号及分数，并按分数高低降序排列，如果分数相同，则按学号升序排序select stuid, scorefrom scoreorder by score desc, stuid asc;\n\n\norder by 子句后指定的排序依据除了能是字段名，还能是查询后的字段顺序值（即 select 语句后跟着的字段顺序，值为1,2,3…），如上述例子还可写为 select stuid,score from score order by 2 desc; ；\n若排序字段为空值，则该值为最小值，即在降序排序中空值显示在最后，在升序排序中显示在最前；\n当  order by 子句后的字段值为数字或字母时，即按照数字或字母的顺序进行排序，当字段值为中文汉字时，会根据对应字符的ASCII码排序，而不是汉字的首字母顺序，因此排序结果往往都是错误的，这时需要借助相应的函数才能实现想要的效果；\n\n5.2 limit 分页查询limit 子句常常应用于分页系统，控制在某一页中显示的数据记录数量，通常与 order by 子句一起使用，其基本语法如下：\nselect 字段1,字段2...from 表名limit 起始索引, 查询记录数;# 例如，查询 score 表中的学号及分数，每页显示十名，查询第二页的数据select stuid,scorefrom scorelimit 1,10;\n\n注意：\n\n起始索引即查询的起始数据的索引，起始索引从 0 开始，查询记录数即查询结果显示的行数，如 limit 10,5 ，即表示从数据表的第 11 行开始，一共查询显示 5 行，利用这个特性可以实现分页查询效果，分页的起始索引 &#x3D; ( 查询页码 - 1 ) * 每页显示记录数，如，一页显示 10 行，要查询第 3 页的数据，起始索引应为 (3-1)*10&#x3D;20，SQL语句写为 limit 20,10；\n当查询第一页数据，即起始行 a 为 0 时，起始索引可以省略，如查询第 1 页，显示 6 行，可以简写为 limit 6；\n当 limit a 中查询结果记录总数不足 a 行，则按实际结果集记录数量显示；\n分页查询的语句不同数据库各有不同，limit 仅是 MySQL 中的分页查询语句；\n当 limit 子句 和 offset 子句一起出现时，limit 子句决定显示行数，offset 子句决定显示起始点，如 limit 3 offset 6 表示从第 7 行开始，显示 3 行；\n\n6. 基础查询的编写和运行顺序基础查询的编写顺序和运行顺序是不同的，具体内容如下。\n6.1 基础查询的编写顺序基础查询的编写顺序为 select -&gt; from -&gt; where -&gt; group by -&gt; having -&gt; order by -&gt; limit\n# 例如，查询score表中分数大于60，平均分大于80的学生的学号和平均分，以学号分组，按平均分倒序排列，从第四个开始显示，只显示五行select stuid 学号,avg(score) 平均分from scorewhere score &gt; 60group by stuidhaving 平均分 &gt; 80order by 平均分 desclimit 3,5;\n\n6.2 基础查询的运行顺序基础查询的编写顺序如下\nfrom 数据表列表where 条件列表group by 分组字段列表having 分组后条件列表select 查询字段列表order by 排序字段列表limit 分页参数","categories":["MySQL学习笔记"],"tags":["MySQL","学习笔记"]},{"title":"MySQL01-MySQL基础概念&数据类型","url":"/2024/01/29/MySQL01-MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5&%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","content":"1. 数据库相关概念1.1 数据库的四个基本概念1.1.1 数据（Data）即 data，数据是数据库中存储的基本对象，是用来描述事物的符号记录，数据有两个特点：\n\n数据在不同的语境有不同的含义，也称语义；\n数据与数据的语义是不可分割的；\n\n1.1.2 数据库（DB）即 DataBase，数据库就是存储数据的仓库，是长期存储在计算机内的，有组织的，可共享的大量数据的集合。数据库有以下基本特征：\n\n数据按一定的数据模型组织、描述和储存；\n可为各种用户共享、冗余度较小、易扩展；\n数据独立性较高；\n\n1.1.3 数据库管理系统（DBMS）即 DataBase Management System，数据库管理系统就是操作和管理数据库的大型软件，是为了科学地组织和存储数据，高效地获取和维护数据而开发的、位于数据库应用系统和操作系统之间的大型而复杂的软件系统，主流的关系型数据库管理系统有Oracle、MySQL、Microdoft SQL Server等。\n1.1.4 数据库系统（DBS）即 DataBase System，数据库系统是指在计算机系统中引入数据库后的系统组成，在不引起混淆的情况下常常把数据库系统简称为数据库，包括数据库、数据库管理系统（及外围的应用开发工具）、数据库应用程序和数据库管理员（DBA）四个基本构成，其中数据库管理系统是整个数据库系统的核心。\n1.2 数据库其他概念1.2.1 关系型数据库（RDBMS)即建立在关系模型基础上，由多张相互连接的二维表组成的数据库。关系型数据库有两个特点：\n\n使用表存储数据,格式统一，便于维护；\n使用 SQL 语言操作，标准统一，使用方便；\n\n1.7 基本概念间的关系用户（如数据库管理员）通过 SQL 语言操作数据库管理系统，通过数据库管理系统管理数据库及数据库里的数据，这个过程又是在数据库系统里完成的。\ngraph LR\n    subgraph 数据库系统\n    A(\"数据库管理员（DBA）\") -- 通过SQL操作 --> B(\"数据库管理系统（DBMS）\")\n    B -- 管理 --> C(\"数据库（DB）\")\n    C -- 包含 --> D(\"数据（Data）\")\n    end\n\n2. 数据库存储结构在存储数据的过程中会用到数据库服务器，所谓数据库服务器，简单来说就在计算机上安装一个数据库管理系统（如MySQL），这个计算机就是一个简单的数据库服务器，数据库服务器建立在数据库系统基础上，拥有数据库系统的特性。\n数据库管理系统可以管理多个数据库，一般开发人员会针对一个应用创建一个数据库，为保存应用中实体的数据，会在数据库中创建多个表（用于存储和描述数据的逻辑结构），每个表都记录着实体的相关信息。\n数据库服务器、数据库和表的关系如图所示：\nflowchart LR\n    A((用户1))  D(Web服务器);\n    B((用户2))  D;\n    C((用户3))  D;\n    D  E(\"数据库管理系统（DBMS）\");\n    subgraph 数据库服务器\n    E  F[(数据库1)]\n    E  G[(数据库2)]\n    F --- H(数据表1);\n    F --- I(数据表2);\n    G --- J(数据表1);\n    G --- K(数据表2);\n    end\n\n数据库中包括表和索引，表则由表头、表的记录和表的字段组成。数据存储在表中，表的横向称为行，每一行的内容为记录，表的纵向称为列，每一列的内容为字段。数据表组成结构如下：\n\n3. SQL基本概念3.1 SQL的概述Structure Query Language(结构化查询语言) 简称SQL，它被美国国家标准局(ANSI)确定为关系型数据库语言的美国标准，后被国际化标准组织(ISO)采纳为关系数据库语言的国际标准。数据库管理系统可以通过SQL管理数据库；定义和操作数据，维护数据的完整性和安全性。\n3.2 SQL的优点\n简单易学，具有很强的操作性；\n绝大多数重要的数据库管理系统均支持SQL；\n高度非过程化，用SQL操作数据库时大部分的工作由DBMS自动完成；\n\n3.3 SQL的分类SQL语言共分为四大类：数据定义语言DDL，数据操纵语言DML，数据控制语言DCL，数据查询语言DQL\n\nDDL(Data Definition Language)数据定义语言，用来操作数据库、表、列等； 常用语句：CREATE、ALTER、DROP\nDML(Data Manipulation Language)数据操纵语言，用来操作数据库中表的数据；常用语句：INSERT、UPDATE、DELETE、SELECT\nDCL(Data Control Language)数据控制语言，用来操作访问权限和安全级别； 常用语句：GRANT、REVOKE、DENY\nDQL(Data Query Language)数据查询语言，用来查询数据 常用语句：SELECT\n\n3.4 SQL的通用语法\nSQL语句可以单行或多行书写，以分号结尾。\nSQL语句可以使用 空格或缩进 来增强语句的可读性。\nMySQL数据库的SQL语句不区分大小写，关键字建议使用大写。\nMySQL注释：\n\n单行注释：-- 注释内容 或 # 注释内容(MySQL特有)多行注释：/* 注释内容 */\n\n4. 数据库数据类型使用MySQL数据库存储数据时，不同的数据类型决定了 MySQL存储数据方式的不同。为此，MySQL数据库提供了多种数据类型，其中包括整数类型、浮点数类型、定点数类型、日期和时间类型、字符串类型、二进制等数据类型。\n4.1 数值类型需要注意的是，数值类型分为带符号的（signed）和无符号的（unsigned）两种，这里的符号指的是 - 号，带符号类型可以表示正数、负数或 0，无符号类型则仅能表示大于等于 0 的值。\n使用时，数值类型默认都是带符号的，要表示一个数值类型无符号，只需在该类型后加 unsigned 即可，如以下用无符号 TINYINT 类型表示年龄：\nage tinyint unsigned\n\n4.1.1 整数类型根据数值取值范围的不同，MySQL 中的整数类型可分为5种，分别是 TINYINT、SMALUNT、MEDIUMINT、INT 和 BIGINT，其中最常见的即为 INT 类型。\n\n\n\n数据类型\n字节数\n无符号数的取值范围\n带符号数的取值范围\n描述\n\n\n\nTINYINT\n1\n0~255\n-128~127\n小整数值\n\n\nSMALLINT\n2\n0~65535\n-32768~32768\n大整数值\n\n\nMEDIUMINT\n3\n0~16777215\n-8388608~8388608\n大整数值\n\n\nINT(INTEGER)\n4\n0~4294967295\n-2147483648~ 2147483648\n大整数值\n\n\nBIGINT\n8\n0~18446744073709551615\n-9223372036854775808~9223372036854775808\n极大整数值\n\n\n4.1.2 浮点数、定点数类型在MySQL数据库中使用浮点数和定点数来存储小数，浮点数的类型有两种：单精度浮点数类型（FLOAT）和双精度浮点数类型（DOUBLE），而定点数类型只有一种 DECIMAL 类型。\n\n\n\n数据类型\n字节数\n无符号数的取值范围\n带符号的取值范围\n\n\n\nFLOAT\n4\n0 和 1.175494351E-38~3.402823466E+38\n-3.402823466E+38~-1.175494351E-38\n\n\nDOUBLE\n8\n0 和 2.2250738585072014E-308~1.7976931348623157E+308\n-1.7976931348623157E+308~2.2250738585072014E-308\n\n\nDECIMAL（M,D）\nM+2\n0 和 2.2250738585072014E-308~1.7976931348623157E+308\n-1.7976931348623157E+308~2.2250738585072014E-308\n\n\n其中，DECIMAL 类型的取值范围与 DOUBLE 类型相同，但是，DECIMAL类型的有效取值范围是由M和D决定的，其中，M表示的是数据的长度，D表示的是小数点后的长度，比如，将数据类型为 DECIMAL(6,2) 的数据 6.5243 插人数据库后显示的结果为 6.52。\n4.2 字符串类型MySQL 中的字符串类型有以下几种，其中常用的是 CHAR 和 VARCHAR。\n\n\n\n数据类型\n储存范围\n用途\n\n\n\nCHAR\n0~255\n定长字符串\n\n\nVARCHAR\n0~65535\n变长字符串\n\n\nTINYBLOB\n0~255\n不超过255个字符的二进制字符串\n\n\nTINYTEXT\n0~255\n短文本字符串\n\n\nBLOB\n0~65535\n二进制形式的长文本数据\n\n\nTEXT\n0~65535\n长文本数据\n\n\nMEDIUMBLOB\n0~16777215\n二进制形式的中等长度文本数据\n\n\nMEDIUMTEXT\n0~16777215\n中等长度文本数据\n\n\nLONGBLOB\n0~4294967295\n二进制形式的极大文本数据\n\n\nLONGTEXT\n0~4294967295\n极大文本数据\n\n\n对于 CHAR 类型和 VARCHAR 类型，CHAR 存储定长的字符串，VARCHAR 存储可变长度的字符串，两者的应用也有区别。\nCHAR 类型数据所占空间是固定的，当数据为 CHAR(m) 类型时，不管插入值的长度是实际是多少它所占用的存储空间都是m个字节，因此 CHAR 类型适合用于数据长度固定的场景，比如性别、用户ID等；\nVARCHAR 类型数据所占空间是随实际数据长度变化的，当数据为VARCHAR(m) 时，所对应的数据所占用的字节数为实际长度加1，因此 VARCHAR 类型用于表示大文本数据，例如，文章内容、评论、详情等。\n4.3 日期与时间类型MySQL提供的表示日期和时间的数据类型分别是 ：YEAR、DATE、TIME、DATETIME 和 TIMESTAMP。在SQL语句中使用日期常量时，必须用英文的单引号或双引号引起来，否则执行结果不正确：\n\n\n\n数据类型\n字节数\n取值范围\n日期格式\n零值\n\n\n\nYEAR\n1\n1901~2155\nYYYY\n0000\n\n\nDATE\n3\n1000-01-01~9999-12-31\nYYYY-MM-DD\n0000-00-00\n\n\nTIME\n3\n-838:59:59~ 838:59:59\nHH:MM:SS\n00:00:00\n\n\nDATETIME\n8\n1000-01-01 00:00:00~9999-12-31 23:59:59\nYYYY-MM-DD HH:MM:SS\n0000-00-00 00:00:00\n\n\nTIMESTAMP\n4\n1970-01-01 00:00:01~2038-01-19 03:14:07\nYYYY-MM-DD HH:MM:SS\n0000-00-00 00:00:00\n\n\n其中，YEAR 类型表示年份值；DATE 类型表示日期值；TIME 类型表示时间值或持续时间；DATETIME 类型表示混合日期和时间值；TIMESTAMP 类型表示混合日期和时间值，即时间戳。\n4.4 二进制类型在MySQL中常用 BLOB 类型数据存储二进制类型的数据，例如：图片、PDF文档等。\n\n\n\n数据类型\n储存范围\n\n\n\nTINYBLOB\n0~255\n\n\nBLOB\n0~65535\n\n\nMEDIUMBLOB\n0~16777215\n\n\nLONGBLOB\n0~4294967295\n\n\n","categories":["MySQL学习笔记"],"tags":["MySQL","学习笔记"]},{"title":"MySQL05-数据操作之多表查询","url":"/2024/01/29/MySQL05-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E4%B9%8B%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/","content":"1. 多表关系数据库中多表间的关系有一对多&#x2F;多对一、多对多、一对一三类。\n1.1  一对多&#x2F;多对一一对多&#x2F;多对一的关系指 A 表的一行对应 B 表的多行， B 表的一行只对应 A 表的一行，比如一个班级可以有多个学生，一个学生却只能有一个班级。\n案例：部门与员工、班级与学生、商品分类与商品\n外键实现：在多的一方建立外键，指向一的一方的主键。\n数据特点：\n\n添加数据时，主表可以随意添加，从表添加数据必须依赖主表，受主表限制；\n删除数据时，如果主表某一行的数据受到从表的依赖，则不能删除，从表数据可以随意删除，如果一定要删除主表数据，应该先删除有关联得从表数据后再删除；\n\n1.2 多对多多对多的关系指 A 表的一行对应 B 表的多行，B 表的一行也对应 A 表的多行，比如一个学生可以选多门课程，一门课程也可以供多个学生选修。\n案例：学生与课程\n外键实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键\n数据特点：\n\n添加数据时，先添加两张父表记录，再添加中间表记录；\n\n删除数据时，先删除中间表记录，再删除两张父表记录；\n\n\n1.3 一对一一对一的关系指 A 表的一行对应 B 表的一行，反之也成立，多用于单表拆分，即将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率，具有一对一关系的两张表是可以合并成一张表的。\n案例：用户与用户详情\n外键实现：\n\n在任意一方加入外键，关联另外一方的主键，并且给外键设置唯一约束；\n共享主键，即让两张表的主键内容一致，两张表共用一个主键（十分不推荐）；\n\n2. 多表查询概述当直接对多张表进行合并查询时，查询的数据结果将会是这几张表的笛卡尔积，假如 A 表有 3 条数据，B 表有 4 条数据，结果就会有 3 * 4 &#x3D; 12 条数据，也即会展示所有组合结果。\n# 合并查询，会展示两张表的笛卡尔积select * from A表, B表;\n\n在多表查询时，为了获得真正需要的数据，就要消除无效的笛卡尔积，由此就有了以下多表查询方法：\n多表查询├─ 连接查询│\t├─ 内连接查询│\t│\t├─ 隐式内连接查询│\t│\t└─ 显式内连接查询│\t├─ 外连接查询│\t│\t├─ 左外连接查询│\t│\t└─ 右外连接查询│\t└─ 自连接查询└─ 子查询\n\n3. 内连接查询-DQL所谓内连接(inner join)，就是在表关系的笛卡尔积(Cartesian product) 数据记录中，保留表关系中所有匹配的数据记录，舍弃不匹配的数据记录，相当于查询两张表的交集部分。根据不同的语法形式，内连接查询分为隐式内连接查询(SQL86标准)和显式内连接查询(SQL92标准)。\n3.1 隐式内连接查询隐式内连接，就是使用 where 条件，消除不符合条件的无用数据，也即消除笛卡尔积的无用数据，其基本语法如下：\nselect 字段1,字段2...from 表1,表2...where 连接条件/筛选条件# 例如，查询 student 和 score 表中的学生姓名及分数select stuname,scorefrom student,scorewhere student.stuid = score.stuid;\n\n3.2 显式内连接查询显式内连接，就是使用 连接关键词 join 显式连接多个表数据，显式的性能比隐式高，其基本语法如下：\nselect 字段1,字段2...from 表1 [inner] join 表2 on 连接条件[inner] join 表3 on 连接条件[where 筛选条件]# 例如，查询 student 和 score 表中的学生姓名及分数select stuname,scorefrom student join score on student.stuid = score.stuid;\n\n3.3 内连接注意事项\n隐式内连接中，where 子句后面往往首先是多表之间的连接条件，需要的话也可用 and 运算符将筛选条件与之联合，where 子句之后的筛选条件语法与单表查询语法类似；\n隐式内连接中，where 子句后面可以有 GROUP BY、HAVING、ORDER BY 等子句；\n显式内连接中，[inner] join 的 inner 可以缺省，仅 join 就代表内连接；\n显式内连接中，每个 join 子句之后必须有 on 子句，on 子句用来说明两表之间的内连接关系；\n显式内连接中，where 子句在此仅用于控制数据筛选条件的限定，用法与表单查询类似，后面也可以有 GROUP BY、HAVING、ORDER BY 等子句；\n显式内连接查询比隐式内连接查询应用更广泛；\n内连接条件在很多情况下发生在有关系的数据表主外键之间；\n多表查询时，如果关联的两个数据表中存在同名字段，则同名字段前必须加表名限定，其格式为 表名.字段名，此时为了书写方便，往往会给表取一个别名，该别名仅在当前 select 语句内部有效；\n在连接查询中常用 表名.字段名 的形式引用字段，主要是引用同名字段的需要，再多表查询中，对于非同名字段也建议采用这种形式，这将有利于提升查询效率；\n\n4. 外连接查询-DQL内连接是将满足条件的记录进行连接，不满足条件的记录是被排除在结果集之外的，如果需要的数据还涉及不满足条件的记录，就需要进行外连接查询。MySQL目前不支持全外连接查询，但可以用其他方式替代解决，如可通过联合多个查询的方式达到全外连接查询的效果。外连接查询分为左外连接查询和右外连接查询，左外连接指查询左表所有数据，以及两张表交集部分数据，右外连接指查询右表所有数据，以及两张表交集部分数据。\n4.1 左外连接查询左外连接时以左表为基本表，左表的内容全部显示，根据连接条件，右表与左表匹配的内容正常连接(中间重合部分)，无法匹配的内容则用空值与左表连接，其基本语法如下：\nselect 字段1,字段2...from 左表 left [inner] join 右表 on 连接条件[where 筛选条件]# 例如，查询 student 和 score 表中的学生姓名及分数select stuname,scorefrom student left join score on student.stuid = score.stuid;\n\n4.2 右外连接查询右外连接与左连接查询语法相同，只是以右表为基本表，右表的内容全部显示，根据连接条件，左表与右表匹配的内容正常连接(中间重合部分)，无法匹配的内容则用空值与右表连接，其基本语法如下：\nselect 字段1,字段2...from 左表 left [inner] join 右表 on 连接条件[where 筛选条件]# 例如，查询 student 和 score 表中的学生姓名及分数select stuname,scorefrom score right join student on student.stuid = score.stuid;\n\n4.3 外连接注意事项\n左外连接和右外连接的形式和作用基本一样，唯一区别就是所关联数据源的顺序不同，两种类型的外连接查询语句可互换，具体使用哪种形式没有特别要求，根据方便程度决定即可，一般使用左外连接更多一点；\n外连接查询时可以通过 where 子句筛选数据，where 子句后面可以有 GROUP BY、HAVING、ORDER BY 等子句；\n外连接结果集是基本表的全部内容加上左右表的重复内容，也就是说外连接结果集包含内连接结果集；\n左右外连接查询时，将左右表的位置互换，并更改 left join 或 right join 为对方，就可实现左右外连接互换；\n\n5. 自连接查询-DQL连接操作不仅可以在两个数据表之间进行，也可以是一个数据表与自己进行连接，称为表的自连接，也称为自身连接，自连接查询的语法同内连接查询的语法一样，只是多个数据表都是由同一个物理表形成的，自连接查询必须使用表别名，其基本语法如下：\nselect 表别名1.字段1, 表别名1.字段2... 表别名2.字段1, 表别名2.字段2...from 表1 [as] 表别名1 [inner] join 表2 [as] 表别名2 on 连接条件[where 筛选条件]# 例如，查询 score 表中两门课成绩都大于 90 的学生学号及分数select distinct t1.stuid, t1.score 成绩一, t2.score 成绩二from score t1 join score t2 on t1.stuid = t2.stuidwhere t1.cid != t2.cid and t1.score &gt; 90 and t2.score &gt; 90;\n\n注意：\n\n自连接是一种特殊的内连接，只要给数据表取两个不同的别名，就可以在逻辑上将一个物理表当成两个表来使用；\n在自连接时，所有列都是两表共有的同名列，对列的运用必须使用 别名.列名 的形式，否则出现二义性；\n自连接查询既可以是内连接查询，也可以是外连接查询，查询语法也可以随查询目的在内连接和外连接查询中选择；\n\n6. 联合查询-DQL联合查询又叫合并查询、连接查询，是用 union 或 union all 语句将两条或两条以上的 select 语句的查询结果集合并，其基本语法如下：\nselect 字段1,字段2...from 表1union / union allselect 字段1,字段2...from 表2;# 例如，查询 student 表中学生姓名和学号select stuidfrom studentunion allselect stunamefrom student;\n\n注意：\n\nUNION ALL 将两个查询结果合并，对于重复的数据不做去重操作；\nUNION 将两个查询结果合并，对于重复的数据会做去重操作；\n被合并的所有查询列数必须保持一致，对应列的数据类型必须兼容；\n联合查询比使用 or 效率高，不会使索引失效；\n\n7. 子查询-DQL在 SQL 中，一个 select-from-where 查询语句称为一个查询块，将一个查询块嵌套在另一个查询块中的查询称为嵌套查询，嵌套在查询块中的内层查询称为子查询，相应的外层查询称为父查询。SQL 也支持多层嵌套子查询，即一个子查询中还可以嵌套其他子查询。\n根据子查询中查询到的结果集规模的不同，可以将子查询分为单值子查询、列子查询、行子查询和表子查询。\n子查询使用的位置可以在 where(having)、from 和 select，最常用在父查询的 where 子句或 having 子句中，与比较运算符或者逻辑运算符一起构成 where 筛选条件或 having 筛选条件。\n7.1 标量子查询当子查询的结果集为单个值（单行单列）时，称之为标量子查询，也叫单值子查询。标量子查询中，父查询常用 =、&lt;=&gt;、&lt;、&gt;、&lt;=、&gt;=、!=、&lt;&gt;、!&lt;、!&gt; 等比较运算符与子查询进行连接，其基本语法如下：\nselect 字段1, 字段2 ...from 表2where 字段3 比较运算符 (单值子查询);# 例如，联合 class 和 teacher 表查询软件1班的班主任的姓名、性别和年龄select name, sex, agefrom teacherwhere name = (select teaid from class where classname = &#x27;软件1班&#x27;);\n\n注意：\n\n标量子查询一般表现为父查询与子查询之间用 =、&lt;=&gt;、&lt;、&gt;、&lt;=、&gt;=、!=、&lt;&gt;、!&lt;、!&gt; 等比较运算符进行连接，而且通常子查询的位置在关系比较运算符的右侧；\n子查询内容必须用括号 () 包围，否则语法会出错；\n子查询一般都可以通过连接查询实现相同功能；\n\n7.2 列子查询当子查询结果即为一列值（单列多行）时，称为列子查询，列子查询作为外层 select 语句的查询条件，一般通过 in、any、some 和 all 等操作符进行关联，不能用关系比较运算符关联，其基本语法如下：\nselect 字段1, 字段2 ...from 表2where 字段3 [in any some all] (列子查询);# 例如，联合 student 和 score 表查询软件1班全体学生的姓名、学号、课程编号和分数select stuid, cid, score from score where stuid in (select stuid from student where class = &#x27;软件1班&#x27;);\n\n注意：\n\n列子查询不能用关系比较运算符与外层查询关联；\n列子查询常用操作符及其含义如下：\n\n\n\n\n操作符\n描述\n\n\n\nIN\n在子查询返回的指定集合范围内，多选一\n\n\nNOT IN\n不在子查询返回的指定集合范围内\n\n\nANY\n子查询返回列表中，满足任意一个值即可\n\n\nALL\n子查询返回列表的所有值都必须满足\n\n\nSOME\n与ANY等同，使用SOME的地方都可以使用ANY\n\n\n7.3 行子查询当子查询结果即为一行值（单行多列）时，称为行子查询，但是这种情况一般很少出现。其基本语法如下：\nselect 字段1, 字段2 ...from 表2where (字段3, 字段4) [= / &lt; / &gt; / IN / NOT IN] (行子查询); # 例如，在 student 中查询与学号 24030101 同岁同班的同学的姓名和学号select name, stuid from studentwhere (age, classid) = (select age, classid from student where stuid = 24030101); \n\n注意：\n\n标量子查询一般表现为父查询与子查询之间用 =、&lt;、&gt;、in、not in 等进行连接；\n行子查询中一般将子查询得到的数据作为一个整体进行处理或者与其他行进行比较；\n\n7.4 表子查询若子查询结果即为多行多列，则称为表子查询。在 select 语句中所有能使用数据源的地方都可以插入表子查询，表子查询比较常见的嵌入位置为 where 与 from 子句。其基本语法如下：\n# 格式一：select 字段1, 字段2 ...from 表2where (字段3, 字段4) [in any some all] (表子查询);# 格式二：select 字段1, 字段2from (表子查询) as 表1别名 join 表2 as 表2别名 on 条件表达式;# 例一，查询与与学号 24030101、24030102 同岁同班的同学的姓名和学号select stuname, stuid from student where (age, classid) in(select age, classid from student where stuid = &#x27;24030101&#x27; or  stuid = &#x27;24030102&#x27;);# 例二，查询各科目的考试成绩，包括科目名称、最高分、最低分、平均分select c.cname, s.maxscore, s.minscore, s.avgscorefrom (select cid, max(score) as maxscore, min(score) as minscore, avg(score) as avgscore      from score group by cid) as sleft join course as c on c.cid = s.cid;\n\n注意：\n\n表子查询嵌入外层查询的 where 子句时，通常用 in、any、some 和 all 等集合运算符与外层查询关联；\n表子查询嵌套在外层查询的 from 子句必然要与其他数据表进行连接，为了能在外层查询中引用该虚拟表及其内部各列，必须为虚拟表设置表别名，如果虚拟表内部有统计列或计算列，同样需要设置列别名，否则无法引用；\n\n7.5 子查询注意事项\n标量子查询、行子查询嵌入外层查询的 where 子句时，通常用关系运算符与外层查询关联，列子查询、表子查询嵌入外层查询的 where 子句时，通常用 in、any、some 和 all 等集合运算符与外层查询关联；\norder by 子句不能用于子查询，只能对最外层的查询结果进行排序；\n设计多层嵌套的子查询时建议与测试顺序一样，从最内层值查询开始，逐步向外层延伸；\n子查询可以嵌套多层，但嵌套级别越多，效率越低，必要时可以通过连接查询来代替多层嵌套查询；\n子查询外部的语句不仅可以是 SELECT 查询语句，还可以是 INSERT &#x2F; UPDATE &#x2F; DELETE &#x2F;  的任何一个\n几乎所有多表查询任务都可以通过嵌套查询或连接查询实现，在实际海量数据应用场景中，应该根据效率优先原则确定查询语句；\n\n7.6 子查询的相关性与执行顺序根据子查询的查询条件是否依赖父查询可以把子查询分为非相关子查询和相关子查询。若子查询不依赖父查询，则这类子查询称为不相关子查询，若依赖父查询，则称为相关子查询，不相关子查询的子查询可以单独执行，相关子查询的子查询不能单独执行。\n7.6.1 非相关子查询非相关子查询的子查询不依赖父查询，独立于外部查询，可以单独执行。\n执行过程：\n\n执行子查询，其结果不被显示，而是传递给外部查询，作为外部查询的条件使用；\n执行外部查询，并显示整个结果；\n\n示例：\n# 例如，联合 class 和 teacher 表查询软件1班的班主任的姓名、性别和年龄select name, sex, agefrom teacherwhere name = (select teaid from class where classname = &#x27;软件1班&#x27;);# 1. 首先执行子查询 select teaid from class where classname = &#x27;软件1班&#x27; ；得到软件1班班主任的 id# 2. 然后将这个 id 传递给外部查询，作为其 where 子句的执行条件# 3. 根据这个执行条件，找到需要的数据\n\n7.6.2 相关子查询相关子查询必须依赖父查询，其子查询不能返回独立的结果集，多数情况下是子查询的 WHERE 子句中引用了外部查询的表。\n执行过程：\n\n从外层查询中取出一个元组（一行数据），将元组相关列的值传给内层查询；\n执行内层查询，得到子查询操作的值；\n外查询根据子查询返回的结果或结果集得到满足条件的行；\n然后外层查询取出下一个元组重复步骤 1-3，直到外层的元组全部处理完毕；\n\n示例：\n# 查询 score 表中分数高于该课程平均分的学生学号和成绩select stuid, score from score as awhere score &gt; (select avg(score) from score as b where a.cid = b.cid);# 1. 假设 score 表中的第一条记录的 cid 的值为 2401，将其代入子查询中，使 a.cid 值为 2401# 2. 由此子查询变为 select avg(score) from score as b where &#x27;2401&#x27; = b.cid# 3. 执行上一步得到的子查询，结果为课程编号为 2401 的课程的平均分# 4. 将该子查询值代回外部查询，变为 select stuid, score from score as a where score &gt; &#x27;2401课程平均分&#x27;# 5. 如果外部查询结果成立，则留下该次查询结果，否则舍弃，重复该过程，最后得到最终的结果集\n\n8. 交叉连接查询-DQL交叉连接是没有任何限制条件的连接，也称为笛卡尔连接，因为其产生的结果集与笛卡尔积范围一样，将产生两个数据源能连接的最大结果集，除了包含内连接，外连接的所有数据外，还有大量没有意义的数据，所以交叉连接几乎没有实际应用价值，其基本语法如下：\nselect 字段1,字段2...from 表1 cross [inner] join 表2;# 例如，将 score 和 student 表交叉连接后展示所有数据select *from score cross join student;\n\n注意：\n\n交叉连接查询中，join 关键字后面没有 on 子句，也就是不设连接条件；\n交叉连接查询中，最大字段数（列数）&#x3D; 左表字段数 + 右表字段数，最大记录数（行数）&#x3D; 左表记录数 * 右表记录数；\n交叉连接查询是从左表依次取出每一条记录，与右表中的全部记录逐个、无条件地连接，因此产生出两个数据表连接的最大结果集；\n\n","categories":["MySQL学习笔记"],"tags":["MySQL","学习笔记"]},{"title":"MySQL07-函数&事务","url":"/2024/01/30/MySQL07-%E5%87%BD%E6%95%B0&%E4%BA%8B%E5%8A%A1/","content":"1. 函数函数是指一段可以直接被另外一段程序调用的程序或代码，在MySQL中，函数已经被内置，只需要进行相关调用操作即可。其中，常用的有字符串函数、数值函数、日期函数和流程函数四类，函数可配合 SQL 的增删查改语句使用。\n1.1 字符串函数MySQL中内置了很多字符串函数，其中常用的如下：\n\nconcat(s1, s2, …, sn)，字符串拼接，将 s1, s2, …, sn 拼接成一个字符串\n\nselect concat(&#x27;Hello&#x27;, &#x27;World&#x27;);-- 输出：HelloWorld\n\n\nlower(str)，将字符串全部转为小写\n\nselect lower(&#x27;Hello World&#x27;);-- 输出：hello world\n\n\nupper(str)，将字符串全部转为大写\n\nselect upper(&#x27;Hello World&#x27;);-- 输出：HELLO WORLD\n\n\nlpad(str, len, pad)，左填充，用字符串 pad 对 str 的左边进行填充，达到 len 个字符串长度\n\nselect lpad(&#x27;01&#x27;, 5, &#x27;-&#x27;);-- 输出：---01\n\n\nrpad(str, len, pad)，右填充，用字符串 pad 对 str 的右边进行填充，达到 len 个字符串长度\n\nselect rpad(&#x27;01&#x27;, 5, &#x27;-&#x27;);-- 输出：01---\n\n\ntrim(str)，去掉字符串头部和尾部的空格\n\nselect trim(&#x27; Hello World &#x27;);-- 输出：hello world\n\n\nsubstring(str, start, len)，切片，返回字符串 str 从 start 位置起的 len 个长度的字符串，start 的起始索引为 1\n\nselect substring(&#x27;Hello World&#x27;, 1, 5);-- 输出：hello\n\n1.2 数字函数MySQL中常用的数字函数如下：\n\nceil(x)，对数字向上取整\n\nselect ceil(1.5);-- 输出：2\n\n\nfloor(x)，对数字向下取整\n\nselect floor(1.5);-- 输出：1\n\n\nmod(x,y)，返回 x&#x2F;y 的模\n\nselect mod(6, 4);-- 输出：2\n\n\nrand()，括号内无需设定值，返回 0-1 间的随机小数\n\nselect rand();-- 输出：0-1间的随机小数\n\n\nround(x,y)，求参数 x 的四舍五入值，并保留 y 位小数\n\nselect round(3.14159, 3);-- 输出：3.142\n\n1.3 日期函数MySQL中常用的数字函数如下：\n\ncurdate()，返回当前日期（年月日）\n\nselect curdate();-- 输出：yyyy-mm-dd\n\n\ncurtime()，返回当前时间（时分秒）\n\nselect curtime();-- 输出：hh:mm:ss\n\n\nnow()，返回当前日期和时间（年月日时分秒）\n\nselect now();-- 输出：yyyy-mm-dd hh:mm:ss\n\n\nyear(date)、month(date)、day(date)，返回指定 date 时间值的年份、月份、日期\n\nselect year(&#x27;2024-01-10&#x27;); -- 输出：2024select month(&#x27;2024-01-10&#x27;); -- 输出：1select day(&#x27;2024-01-10&#x27;); -- 输出：10\n\n\ndate_add(date, interval expr type)，返回 date 时间值加上一个时间间隔 expr 后的时间值，其中 type 的值可为second、minute、hour、day、week、month、year等时间单位。\n\nselect date_add(&#x27;2024-01-10&#x27;, interval 6 week);-- 输出：2024-02-21\n\n\ndatediff(date1, date2)，返回起始时间 date1 和结束时间 date2 之间的天数\n\nselect datediff(&#x27;2024-01-10&#x27;, &#x27;2025-01-10&#x27;);-- 输出：-366\n\n1.4 流程控制函数\nif(value, t, f)，如果 value 为 true，则返回 t，否则返回 f\n\nselect if(false, &#x27;Ok&#x27;, &#x27;Error&#x27;); -- 输出：Errorselect if(true, &#x27;Ok&#x27;, &#x27;Error&#x27;); -- 输出：Ok\n\n\nifnull(value1, value2)，如果 value1 不为 null，返回 value1，否则返回 value2\n\nselect ifnull(&#x27;Ok&#x27;, &#x27;Error&#x27;); -- 输出：Okselect ifnull(&#x27; &#x27;, &#x27;Error&#x27;); -- 输出：（什么也不输出）select ifnull(null, &#x27;Error&#x27;); -- 输出：Error\n\n\ncase when [ val1 ] then [ res1 ] … else [ default ] end，如果 val1 为 true，返回 res1，否则返回 default 默认值\n\nselect stuname,(case when stuage &gt;= 18 then &#x27;成年&#x27; else &#x27;未成年&#x27; end)from student;\n\n\ncase [ expr ] when [ val1 ] then [ res1 ] … else [ default ] end，如果 expr 的值等于 val1，返回 res1，否则返回 default 默认值\n\nselect stuname,(case addr when &#x27;北京&#x27; then &#x27;一线城市&#x27; when &#x27;上海&#x27; then &#x27;一线城市&#x27; else &#x27;二线城市&#x27; end) as &#x27;家庭地址&#x27;from student;\n\n1.5 案例实践# 将数据库中学生的学号由 3 位数统一为 6 位数，不足六位的在前补 0，如 111 补为 000111update student set stuid = lpad(stuid, 5, &#x27;0&#x27;);-- 通过 lpad() 函数对学号不足六位的在前补 0\n\n# 通过数据库的函数，生成一个六位数的随机验证码。select lpad(round(rand()*1000000, 0), 6, &#x27;0&#x27;);-- 通过 rand() 函数生成一个 0-1 间的随机小数，因为需要六位数字，将这个小时乘以 1000000，得到一个带小数的六位数-- 通过 round() 函数将上一步得到的六位数四舍五入并保留 0 位小数-- 通过 lpad() 函数，防止出现类似于 0.011111 这样的数字乘以 1000000 后不满足六位数的情况，在其前补 0\n\n# 查询所有员工的入职天数，并根据入职天数倒序排序。select name, datediff(curdate(), entnydate) as &#x27;entrydays&#x27; from employee order by entrydays desc;-- 通过 curdate() 函数获取当前日期-- 通过 datediff() 函数求出当前日期和数据库中员工入职日期 entnydate 相差的天数\n\n# 统计班级各个学员的成绩，分数 &gt;= 85 为优秀，分数 &gt;= 60 为及格，否则不及格select id ,name,(case when math &gt;= 85 then &#x27;优秀&#x27; when math &gt;=60 then &#x27;及格&#x27; else &#x27;不及格&#x27; end ) &#x27;数学&#x27;，(case when english &gt;= 85 then &#x27;优秀&#x27; when english &gt;=60 then &#x27;及格&#x27; else &#x27;不及格&#x27; end )&#x27;英语&#x27;,(case when chinese &gt;= 85 then &#x27;优秀&#x27; when chinese &gt;=60 then &#x27;及格&#x27; else &#x27;不及格&#x27; end )&#x27;语文&#x27;from score;-- 通过 case...when...then...else 函数对各分数段进行分类，分别返回不同的值\n\n2. 事务在 MySQL 中，事务是一组 SQL 语句的集合，是一个不可分割的工作单位，事务会把所有数据库操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。\n2.1 事务操作在 MySQL 中，事务的默认提交方式是自动提交，也就是说，当执行一条 DML 语句，MySQL 会立即将这条语句作为一个事务隐式提交。也就是说，在 MySQL 默认设置中，每一条 SQL 语句都是一个事务。这种情况下，如果一个功能需要多个 SQL 语句联合实现，当其中一个 SQL 语句出现错误，剩下的语句就不再执行，进而会影响到数据的一致性，如以下例子\n# 模拟银行转账，在 account 表中存储了张三和李四的账户余额各 2000 元，通过一组 SQL 语句模拟张三给李四转账 1000 元-- 1. 查询张三账户余额select * from account where name = &#x27;张三&#x27;; -- 输出 2000-- 2. 将张三账户余额 -1000update account set money = money - 1000 where name = &#x27;张三&#x27;;-- 3. 将李四账户余额+1000update account set money = money + 1000 where name = &#x27;李四&#x27;;# 可以看到，要想实现这个转账，需要分成三个 SQL 语句，并且要保证三个 SQL 语句依次无误实现# 假设以上第 2 条语句运行后报错，剩下的语句就无法执行，转账就会失败，这时张三的1000元会减去，而李四的钱还是没有增加# 这样一来，数据就出现了问题，数据的一致性丧失\n\n要想避免这个问题，可以将几条 SQL 语句编为一个事务，在同一个事务里的 SQL 语句将被看做一个整体，要么全部执行，要么全部不执行，可以有效维护数据的一致性和完整性。要想将一组 SQL 语句编为一个事务，需要手动更改事务设置，改自动提交事务为手动提交，以下是两种手动提交事务的设置方法：\n方法一（隐式）：\n-- 查看事务提交方式select @@AUTOCOMMIT;-- 设置事务提交方式，1 为自动提交，0 为手动提交，该设置只对当前会话有效set @@AUTOCOMMIT = 0;# SQL 语句-- 如果 SQL 语句执行成功，则提交事务commit;-- 如果 SQL 语句执行时报错，则回滚事务rollback;\n\n方法二（显式）：\n-- 开启事务start transaction;或：begin;# SQL 语句-- 如果 SQL 语句执行成功，则提交事务commit;-- 如果 SQL 语句执行时报错，则回滚事务rollback;\n\n无论使用哪种方法，一旦开启手动提交事务后，只有手动输入 commit; 确认才会改变数据库中的数据。  \n此外，还能在事务中设置保存点，可以使事务回滚到该保存点，而无需全部回滚：\n# 设置事务保存点savepoint savepoint_name;# 回滚到事务保存点rollback to savepoint savepoint_name;\n\n说明：\n\n事务在执行过程中发生错误，应该使用 rollback;  语句回滚，回滚后数据将恢复到该事务执行前的状态。\n在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务；\n事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行；\n事务用来管理 insert、update、delete 语句；\n\n2.2 事务的四大特性(ACID)一般来说，事务必须满足以下 4 个条件（ACID）：\n原子性(Atomicity)：事务是不可分割的最小操作单元，事务中的所有操作要么全部完成，要么全部不完成，不会结束在中间某个环节。一致性(Consistency)：在事务开始之前和事务结束以后，必须使所有数据都保持一致状态，数据库的完整性不能被破坏。隔离性(Isolation)：是数据库系统提供的隔离机制，数据库允许多个并发事务同时对其数据进行读写和修改，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。持久性(Durability)：事务处理结束后（提交或回滚），对数据的修改就是永久的，即便系统故障也不会丢失。\n2.3 并发事务问题并发事务是指多个用户或应用程序同时对同一个数据库进行读取和修改操作的情况。当多个事务同时访问数据库时，由于每个事务都不知道其他事务的存在，所做的操作可能会互相覆盖影响，就会导致一些问题。并发事务的主要问题有以下四个：\n\n更新丢失 (Lost update)当两个或多个事务读入同一个记录并修改，最后一个事务提交的结果覆盖了前面事务提交的结果，导致前面事务的修改丢失，就造成了更新丢失错误。\n\n脏读 (Dirty Reads)一个事务对一条记录做了修改，但还没有提交事务，这时，另一个事务也来读取同一条记录，读取的却是前一个事务修改后的值，之后前一个事务又进行了回滚，记录中的数据恢复到修改前的状态，也就是说后一个事务读取了一个数据库中从未提交的数据，读取的值和数据库中的值不一致，这种现象被叫做脏读。\n\n不可重复读 (Non-Repeatable Reads)一个事务读取了一条记录，这个事务还没结束，这时另外一个事务也访问了同一记录，并对该数据进行了修改，此时第一个事务又一次读取了这条记录，发现读到的结果与之前的结果不同。这种一个事务先后读取同一数据，但获得的值不同的情况，就称为不可重复读。\n\n幻读 (Phantom Reads)一个事务查询到数据表中有 3 条记录，之后另一个事务新插入了一条记录，此时数据表中存在 4 条记录，此时如果前一个事务要插入一样的第 4 条记录，就会发现第 4 条记录已存在，这种类似读取幻觉的情况就叫做幻读。\n\n\n不可重复读和幻读的情况很类似，但不可重复读的重点是修改，同样条件下，读取过的数据，再次读取发现值不一样；幻读的重点在于新增或者删除，同样条件下，第一次和第二次读出来的记录数不一样。\n2.4 事务隔离级别2.4.1 隔离级别概述为了避免并发事务对数据造成的影响，最常用的方法是利用封锁技术进行并发控制。封锁技术的缺点是会造成死锁和性能下降，为了兼顾并发效率与异常控制，定义了以下 4 种隔离级别：\n\n读未提交 (Read uncommitted)如果一个事务已经开始写数据，则另外一个事务不允许同时进行写操作，但允许其他事务读到此行未提交的数据。该隔离级别可以通过“排他写锁”实现。\n\n读已提交 (Read committed)读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行数据，也就是说读取数据的事务可以读取到其他事务已经提交的数据，未提交的写入事务则读取不到。\n\n可重复读 (Repeatable read)读取数据的事务将会禁止写入事务（但允许读事务），写入事务则禁止任何其他事务。也就是说，一个读取事务开启后，无论其他写入事务如何进行修改操作，读取的数据始终是一样的。这是 MySQL 默认的隔离级别。\n\n可串行化 (Serializable)要求事务串行化执行，事务只能一个接着一个地执行，不能并发执行。串行化是最高的事务隔离级别，同时数据也最安全，但性能极低，实际开发中很少使用。\n\n\n这 4 种隔离级别可以解决的并发事务问题如下表：\n\n\n\n隔离级别\n更新丢失\n脏读\n不可重复读\n幻读\n\n\n\n读未提交 (Read uncommitted)\n√\n√\n√\n√\n\n\n读已提交 (Read committed)\n√\n×\n√\n√\n\n\n可重复读 (Repeatable read，默认)\n×\n×\n×\n√\n\n\n可串行化 (Serializable)\n×\n×\n×\n×\n\n\n\n√ 表示该隔离级别下依然可能发生该类并发问题，× 表示该隔离级别下已经解决该类并发问题\n各隔离等级的性能：Read uncommitted &gt; Read committed &gt; Repeatable read &gt; Serializable\n各隔离等级的数据安全性：Serializable &gt; Repeatable read &gt; Read committed &gt; Read uncommitted\n各隔离等级的开发性能：Read uncommitted &gt; Read committed &gt; Repeatable read &gt; Serializable\n\n2.4.2 隔离级别设置查看事务隔离级别：\n# 查看系统隔离级别select @@global.tx_isolation;# 查看会话隔离级别（MySQL5.0以上版本）select @@tx_isolation;# 查看会话隔离级别（MySQL8.0以上版本）select @@transaction_isolation;\n\n设置事务隔离级别：\n# 设置会话隔离级别为读未提交set [session|global] transaction isolation level read uncommitted;# 设置会话隔离级别为读已提交set [session|global] transaction isolation level read committed;# 设置会话隔离级别为可重复读set [session|global] transaction isolation level repeatable read;# 设置会话隔离级别为可串行化set [session|global] transaction isolation level serializable;-- session 是会话级别，表示只针对当前会话有效，global 表示对所有会话有效。\n","categories":["MySQL学习笔记"],"tags":["MySQL","学习笔记"]},{"title":"catvod影视及其配置","url":"/2024/01/30/catvod%E5%8F%8A%E5%85%B6%E9%85%8D%E7%BD%AE/","content":"\n  450389b64957f5cb900720a7eaa60c7f06ed9980fce775392c9355266dfb17235cda84e090668ba0dcbffee1ba29c23230daeb603d4bc5bab7fe6723b9df60d16ddf16a52fd64a89b98dc7b28b029e64e318fb277a22b5efca33b0c0fec0fdfa4f147086e1baae76ddd0bc749b45c46bce245bfdf74ffab6cc7aa79b7f855c15fe5f2ea03c16030d5b3413a4466110739899e81192532ce2a14d8895198b404688f36f4e14f2378a837e474c27182acc19a31d1c5a3d6c475abb720ce807ba0d8b4434d279aaf80c7114c03437d67d7d21f26f37b16a6633947cdd1ea44d0c10110462c70ab4a16e1fecf33710abad679a35c5849c31914974d89678ada217ebbb5874926e2dfd3d1594412bc605cd6d4b8a8497a2492406a12cbb580ccdfc7952e21c27a3ce118fb575d9734ed840a28a80be8e7cc2a633c8526dd7c0d794252b2625e71acba2f5151f72009cf389dc0ada4a8011173b7d9adf61907850a2eff5397126211c845a54308c087f7920f33044c5baefc19a92ae6d3add017b99137f31ceeaa4243a85d28942e889544868e7002497d9e4647f8f09bb40e6e9f120dd9bcc5293967809a3e0172185ca2e4ba6ccbee2b409da1d19fe04147b7acd85b397fea910b40076ce36b854b64faa546e199a4e0145d6172c2472f4015584df899f155ffc5539dec3e401aee2922a13cfc1b2eb6dd9eb1139dd18da55a1952e5c15795c526baa0d00377037eeed8817aa29fa5089e5de7df95b54281bf78b0d813ec1e5a08027dbe67b3e354809a7976d271efc979d347580bbec2077244187f359bef9e1e6bf9bf50670b11aedb595aac257b6d5201d777b5c28f266f1758e3310f1288c5471a407c4584b89ff551aff3a820f258eb585ffb666597171b73f8b74254f3d96cff30418c4af3e60e8b00cf3602ff1b358199bc00ef850f26ffd3fc5f520b6856dd4a1229d78cd36ecdeb7320ea8970377641e16c7d5052170e4691b7525248a14b9186beedd74b871b5f030ae2a1e8f9a4ca383ab44a193df7b46ba8de23369c41fde13e256911c29ce701b2969b6c2c5c935bf9a711e4ec74b0b774bc62e4b8ca55dd0977ce6f26890ab24779889a55b74a9e1c8b49da862083eff95c0e76c535ef855bdac23b000d8faef45a573fc1aa043f1093436ad9ca00418de19f326744f57028fed2630fbb50127561412950ed8508753d35b9f7a11612d99d6fd30d7e372540a7a5f9692fb9e1c2892cad34bf32cd4cfb74feebf9e13c9a40c6a3639b15fee6275c6e30ce104741faf7adfeea7b3cf4d31ecf3caf65b3a6343350cb26bd2bcf5b77e7f3ed86e05aa1af66d69c615c3eccf65f17b26bf78615055e70cb5a6614a248d9be4dfb3551a0f670f96c88784d257330f62924e964f9e9e12514b6d96180e1f4f2b15fd47a42c3a9e1c56955107edb5d81ea64c530d04034e2c694017e68d0b3f125e34505013c74e01850c31e2687edb859e092ecd96616de8ff3a7f803c13db96a937842f443620841634fdfeeb08aea6943a4d6287f1af3721f28ffd13858b635a504a1daf4e1ffce311cea2ad412ac194aad17e52411820644fbe9f418b891243f7f29df32eabaa35126f6291aaa9f44c05c5521f80fea2c00d565e821957c44c00ce40d641f2f50225938e0403ccf6c41344449f3711b0fdd1d301fe63123a4210196c2b1c80b8f3fc1006312b6fc41fad4fdbe38a5406e393131ae19c107b141e56eddf205eb7b1b372bf0dce6e2cb7f4542bc3dfed800b1b7069f248e8d382d285ccb55c3b0b4b25ebecca7476511a837612b19474ff38e67f4fa62d7dfd3818c3313e5cdf3ca589286bda8e6a72975d048ca7e0223665d3be62ef93cf32dfcc0652342a6eeff4fb0d3cb9cf2e34291b81893a4c717b26f2ebd283590b00e6070ae395902b98f807a8000223d561aac50da249d6814310037dbbdd89d31e99fb35686639fdffe093991cefcd156ba6f80c4189a09673528b675273dfbf8ee03f264c7de07cbdc346a04800f0d2159a73fab3fb64d0f9b8b0849f8424e0b7287c1aa8916576047e1f5fcb45295fd92e0ce2b771419ed4c4d17e3289729e7c22cbf5552f5d93c2372b98b843023613326208f9f97341d9a4ff79e6f96ffe96fcb0a6bbdba821c0e035be3f36638aafdb6f6ccc8c75d587be7be412b4dae067469ecf160258d1f4376ec3e7aa4ecebe18d912feec68d451f84cd40d7c389b04fdb385d071095bddaf675a3e1fdab675a20652f896c4395c74852d81842113818c07a7f13b76e623f235f11ff87ae52e886c08d07ac190bfecfda792e071fe4b781a231a26e749a5eb31dbbfc1a68b9a5bc02b97be6841ea5310639628e96952d74188cea40daac0f22c2023270bacb7acd52aefda4f1a2fa2caaad1fab3079aed9cf39f29bbd85e796291527264db0c17af0655e0bfba19c2352477fcd6003fb20f41ad97fa20fcef8c8972327fc65f06669b93728d8b922c1b024d138e517812339804598f468de05c9b943d5c9d2de1652fef82dba88e1c692eaab8245c80f4d7a3c0ade1a95fb48041e0a51dd04954aee003e9ed013d30d42cf5e8503105b172c823741da34b61a83c0d2e4060dd41425c1deb354abd6cd4d1b93bd8f886c6ce531877e417006f7e483ab6fdce038f835de0d87414328f8a51d209dfd05d1b82921470b5e03bf9aa583c16b1551322eb66bf8ca8625bef259fa8840edafb7d4ae92373d6a5d7ecc362e5daec33e6059698aaafb69ef8e4984add4e7b40fa44cf28135f747a876e11972d0cd3fa8ea956dda51f840083d47bb8cb7aa32fe161a62e1719d246e70e8098e4d600b17d7ed68eccd686fc0a1a127ce66386f6821c199b14d880e0e862510b09bd2ca0551496cd1d569d2e5ee74445254511b05d6576d0261550592f32dc5ad1544a94ea1a6776c58466e6eb5030d2bc46f2af266c6df8d6da19fe241593cefaecc4fcfa7bebb0348f85b95a3d553633bd3c7906510d457c05949fea47dd7b3cb30a82274ab08782b0a279144078f5a3c4b8a4ce05fec665763ed9d020119c3a8b9feca864dc17aeb37fddc1d52b2cf8cfc321fd31f6a7cfa3ab3f26de68310ccfe06005ca10e0ceb4285daa6415a0584966faab8c3a98ca2dd045b48048c5aa27cd5262444c28ca5304382935296e742ffcebd704719e71b97e10bc6f0f63ce93d0830fd9870beb05eade5469597467e6b0c76f60d1fdb20ceb7352c10fd260eb88a262775ee6c6def7a1e29fbff516682f26043a175794b1a541d85a9606f0ce7e88a5d1d1391f230e6071ca445aead50bbe298d2a9c92b4b69bcc6817239c62762292c5efd24a59004b5a764c7361e3f84f882a04e67371ac0b00ebdd3caf41e18ca9fa75d35a5e646751a6e5451554bdbb4fa7ec75ca9f4aa2771bb951d4c432eebe51d14228a138ed1c89e446399b709346944667339f76b29f0924215ff4a259896e306066963e7c6bb0a393b9919a46b9cf9aec72470657c4faadddfd64b0bacb3bdf521aea6958a66701e17b99bb76e5b4b8fdb0aca3a199db38ff87fda5a1654045a2117f2543d4b4dec3c3a523f8ae98466fa17d7bab1508f447479ac1c923d0369f9caf88ad1a21ca2e427af9af8aaf3264c37eb647310bbcb9d10fc8fb1ddb393fb9bae74e1698c8ccd1e96785ed86f857596bb097408e7c62681969da7476eda43cf39eda5bdd23f51bcfe6d8c7f9dcf2a74f0c24d66399484d34c1b9716e0c2e24c66a1ce10d9a31baf3f5272da765368c600e49f053c346ebfeed48ce6d14786a4920401a69b4c3cf142842cfc3e11e1c58c311b037218bc82fc1a30661d325223aef1cdd3b67be8b68165bb2a3e3c8e91ea41477b81543096126521917aa69187cf0862934e771e108ab8520eef9ae8efc44ec09f5fa49854758ffa4a6d008025f0ead41d16cf2afefe55f4178eb6cd18ef18205f6c47e48c157273c680fc8f8187c48241de7b66dde6bdf498e21f69ea1458c018c2af2a5b7a4da7f101701889874f71ba4b29903566b9d99c82b910190e5f48fe914bd78f45220640ecddecfd8b188e3ac650bc69ff093f3d9f39e71f272c17ed9b4bc4f91884be0e81904007bb281283f2337e8a5961b613e5a8de661236156bb13df64048288d3c07a39ef8a035b30b218681d70f42bedd52ed96046aa892628e7320cda1fc4edf4645d26036f8b3cc252472360188c1c27165376dc81a051054ddb4f6fbeda6428e0e32293eedee4582ef686c0a97f423e3b48f518bc325c128ed7d6e27bdb6685717b89efe771304c4ce9ebc2fb0484e97265fe2cd3e6fcf325bf64eb5d8663c64522b6eea9ecd54cebb430959f818bc23d43e93da8fa4d7cb5258d4a8fd4899851157e64ad26ed658cf3d64001af1571f85013003e1476dfac81d6870a3b78f2e5b27590d0efe1471d476ad5baab9f151220832c65b606762e2fdd6ca26e25a72bab8dc69019ffc312e77f0e624aabbfd09ef28043c1f18b6ddd17d0c07d364c1fb8201582b8e0b249ce7d4075c81995cd92d33c5fb9fda023da3fdd05e600506e4c661b2f8fce7af73b7858ea3b29706944a9febf9ac9533922f810d95d5e684ab6f6ecdde9eb01ee4845f110d09af04417057ac5eca2d716804c33ce66bfb792dad379034b29d53c37c36f94d7147f1366967535444c410f670c06d04671c1bb7a88fb37ff4b871935297813701a36998a28d966b93904a2a72e6cfe61edf17e4fd83a2d534061e98baffaa8d4799c5b86840ade90ba72f7893112bfb2668384f439a1b5905a559bbb2ce26724c6b0f02d6f1c92de7d12fb022b740f0de3f8d542862eee48edff35e5835920fbf9af7f88328ca71824af940be59977a9fd1438a3b0706357a9580ab0ad62cec262f8b301282889aee23c0393f1087cf126754e4c86ae432cb74215272da9c43d3e297a9a61538bd43dde30f3dac7696860ef7556934893ebd6cf05a90ba795851e78d6efc5626637f16cdafb2980eddf2f5ce703fb24738d87b4e9a16a4fa90d50520fc246a293866a41358649af2ebfc2b4a7a3edcf006df337328273f6e436948deacd2610a5a3b05c9a8f974cb99a7c11b14a570d3e88f3904d057832289d0de5e783abf0c260720804d7d316287c15a129aba0405cea7bbd7f5fc86738476696a1541e23d3411286b5973a8499f821b04278bcd5d2975be30c07631661762248ea5c4230448be0abcf706a96b2fa316a534eae29af2056f4495bb71edb00341185dfa8755e0b6717e20187210eba45258a6f0ff8066df358f08739cb466fb0c9\n  \n    \n      \n      \n        Hey, password is required here.\n      \n    \n  \n\n","categories":["娱乐技巧小记"],"tags":["影视","娱乐笔记"]},{"title":"MySQL06-数据控制&约束","url":"/2024/01/29/MySQL06-%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6&%E7%BA%A6%E6%9D%9F/","content":"1. 数据控制-DCL数据控制类 SQL 开发人员操作的比较少，主要是DBA（Database Administrator 数据库管理员）使用。\n1.1 用户管理\n查询用户，MySQL服务器的用户信息存储在 mysql 数据库中的 user 表中，可以通过查询该表查询 mysql 服务器的用户信息\n\n-- 进入 mysql 数据库use mysql;-- 查询 user 表select * from user;\n\n\n创建用户，其中用户名和用户密码可以自定义，主机名为 localhost 时表示本地主机，该用户只可以从本地主机访问数据库服务器，主机名为 % 时表示任意主机，该用户可以从任意主机访问数据库服务器；\n\n-- @ 符号前后不能有空格，否则创建失败create user &#x27;用户名&#x27;@&#x27;主机名&#x27; identified by &#x27;用户密码&#x27;;-- 创建用户test，密码为1234，只能在当前主机localhost访问create user &#x27;test&#x27;@&#x27;localhost&#x27; identified by &#x27;1234&#x27;;-- 创建用户test，密码为1234，能在任意主机访问create user &#x27;test&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;\n\n\n修改用户密码\n\nalter user &#x27;用户名&#x27;@&#x27;主机名&#x27; identified with mysql_native_password by &#x27;新用户密码&#x27;;\n\n\n删除用户\n\ndrop user &#x27;用户名&#x27;@&#x27;主机名&#x27;;\n\n1.2 权限控制\n查询权限\n\nshow grants for &#x27;用户名&#x27;@&#x27;主机名&#x27;;\n\n\n授予权限\n\ngrant 权限1,权限2... on 数据库名.表名 to &#x27;用户名&#x27;@&#x27;主机名&#x27;;-- 授予用户 test 在 student 数据库 user 表的插入和修改权限grant insert,update on student.user to &#x27;test&#x27;@&#x27;localhost&#x27;;-- 授予用户 test 在 student 数据库所有表的所有权限grant all on student.* to &#x27;test&#x27;@&#x27;localhost&#x27;;\n\n\n撤销权限\n\nrevoke 权限1,权限2... on 数据库名.表名 from &#x27;用户名&#x27;@&#x27;主机名&#x27;;-- 撤销用户 test 在 student 数据库 user 表的插入和修改权限revoke insert,update on student.user from &#x27;test&#x27;@&#x27;localhost&#x27;;\n\n其中，MySQL中常用的权限有以下这些，更多权限可以参考官方文档：\n\n\n\n权限\n说明\n\n\n\nALL，ALL PRIVILEGES\n所有权限\n\n\nSELECT\n查询数据\n\n\nINSERT\n插入数据\n\n\nUPDATE\n修改数据\n\n\nDELETE\n删除数据\n\n\nALTER\n修改表\n\n\nDROP\n删除数据库&#x2F;表&#x2F;视图\n\n\nCREATE\n创建数据库&#x2F;表\n\n\n注意：\n\n授予权限时，多个权限之间用逗号分隔；\n授予权限时，数据库名和表名可以用 * 通配表示，代表所有，如授予用户 test 在所有数据库所有表的插入和修改权限：grant insert,update on *.* to &#39;test&#39;@&#39;localhost&#39;;；\n\n2. 约束约束是为防止错误的数据被插入到数据表，作用于表中字段上的规则，用于限制存储在表中的数据，也即表的约束实际上就是表中数据的限制条件。约束可以保证数据表中数据的正确性、唯一性、有效性和完整性。约束是作用于表中字段上的，可以在创建表或修改表的时候添加约束。常见约束如下：\n\n\n\n约束\n关键字\n描述\n\n\n\n非空约束\nNOT NULL\n限制该字段的数据不能为null\n\n\n唯一约束\nUNIQUE\n保证该字段的所有数据都是唯一、不重复的\n\n\n主键约束\nPRIMARY KEY\n主键是一行数据的唯一标识，要求非空且唯一\n\n\n默认约束\nDEFAULT\n保存数据时，如果未指定该字段的值，则采用默认值\n\n\n检查约束（8.0.1版本后支持）\nCHECK\n保证字段值满足某一个条件\n\n\n外键约束\nFOREIGN KEY\n用来让两张图的数据之间建立连接，保证数据的一致性和完整性\n\n\n2.1 列级约束和表级约束MySQL中的约束分为为列级约束和表级约束：列级约束有：非空、唯一、主键、默认、检查、外键（外键约束在语法上支持，但没有效果）表级约束有：唯一、主键、检查、外键\n区别：\n\n列级约束是字段级约束，只能应用于一列上，表级约束是字段间约束，可以应用于一列上，也可以应用在一个表中的多个列上；\n表级约束可以给约束起名，以主键约束为例，格式为以 constraint 约束名 primary key (字段1, ...) ，添加约束名可以方便以后通过这个名字来删除这个约束；\n列级约束和表级约束在添加位置上也有所不同，列级约束直接在 字段名 数据类型 后面追加约束，用空格分隔，表级约束则与字段定义用 , 分隔，在字段定义的最下面，大致位置如下所示；\n\nCREATE TABLE 表名 (字段1 字段类型 列级约束,字段2 字段类型 列级约束,表级约束(字段1, 字段2));\n\n\n2.2 主键约束主键约束（PRIMARY KEY,PK）是指具有唯一标识表中每一行的值的一列或一组列的主键。被标识为主键的数据具有唯一性、非空性和最小化原则，用于强制实现表的实体完整性，类似于身份证号。\n使用主键的时需要注意以下几点：\n\n一个表只能定义一个主键约束（约束只能有一个，但可以作用到好几个字段)；\n给某个字段添加主键约束之后，该字段不能重复也不能为空，效果和 not null unique 约束相同，但是本质不同；\n主键约束会默认添加索引(index)；\n\n主键也分为单字段主键和多字段联合主键，具体要求如下：\n\n一个字段名只能在联合主键字段表中出现一次；\n联合主键不能包含不必要的多余字段，以满足最小化原则；\n\n添加列级主键约束\n-- 创建表时添加约束-- 列级主键约束字段名 数据类型 primary key;-- 表级主键约束create table 表名 (字段名 字段类型,字段名 字段类型,...primary key (字段名,字段名,...));-- 创建表后添加约束-- 方法一alter table 表名 modify column 字段名 数据类型 primary key;-- 方法二alter table 表名 add primary key(字段名);-- 创建表时添加约束-- 方法一，列级主键create table student (id int primary key,name varchar(20));-- 方法二，表级主键create table student (id int,name varchar(20),primary key(id));-- 添加表级主键时可设置多字段联合主键，字段间用逗号分隔create table student (id int,name varchar(20),primary key (id, name));-- 创建表后添加约束-- 方法一alter table student modify column id int primary key;-- 方法二alter table student add primary key(id);\n\n删除主键约束\nalter table 表名 drop primary key;示例：alter table student drop primary key;\n\n2.2.1 主键自增长当主键定义为自增长后，主键的值就不需要自己再输入数据了，而是由数据库系统根据定义自动赋值，每增加一条记录，主键就会自动根据设置的步长进行增长。在MySQL中，自增长的关键字是 AUTO_INCREMENT，语法格式为：\n字段名 数据类型 auto_increment;-- 例如：create table student (id int primary key auto_increment,name varchar(20));-- 还可以设置自增起始数据：create table student (id int primary key auto_increment,name varchar(20)) auto_increment=0001;\n\n2.3 非空约束非空约束（NOT NULL）是指强制字段的值不能为空。\n添加非空约束：\n-- 创建表时添加约束字段名 数据类型 not null;-- 创建表后添加约束alter table 表名 modify column 字段名 数据类型 not null;示例：-- 创建表时添加约束create table student (id intname varchar(20) not null);-- 创建表后添加约束alter table student modify column name varchar(20) not null;\n\n删除非空约束：\nalter table 表名 modify 字段名 数据类型 null;示例：alter table student modify name varchar(20) null;\n\n2.4 唯一约束唯一约束（UNIQUE）用于保证数据表中字段的值具有唯一性，即表中字段的值不能重复出现，允许出现空值，但空值只能出现一次。\n添加唯一约束：\n-- 创建表时添加约束字段名 数据类型 unique;-- 创建表后添加约束-- 方法一alter table 表名 modify column 字段名 数据类型 unique;-- 方法二alter table 表名 add unique(字段名);-- 创建表时添加约束-- 列级唯一约束create table student (id int,name varchar(20) unique);-- 表级唯一约束，当在表级唯一约束中设置两个字段名时，新纪录中的两个字段与这两个字段原有数据都相同则报错，只有一个相同不报错create table student (id int,name varchar(20),unique(id,name));-- 创建表后添加约束-- 方法一alter table student modify column name varchar(20) unique;-- 方法二alter table student add unique(name);\n\n删除唯一约束：\nalter table 表名 drop index 字段名;示例：alter table student drop index number;\n\n2.5  默认约束默认值约束（DEFAULT）用于指定数据表中字段的默认值，当向表中插入一条新的记录时没有给该字段赋值，那么数据库系统会自动为这个字段插人默认值，默认约束常常用在某字段中数据存在大量重复值的情况。\n添加默认约束：\n-- 创建表时添加约束字段名 数据类型 default 默认值;-- 创建表后添加约束alter table 表名 modify column 字段名 数据类型 default 默认值;示例：-- 创建表时添加约束create table student (id int,name varchar(20),gender varchar(10) default &#x27;male&#x27;);-- 创建表后添加约束alter table student modify column gender varchar(10) default &#x27;male&#x27;;\n\n删除默认约束：\n-- 方法一alter table 表名 modify 字段名 数据类型;示例：alter table student modify gender varchar(10);-- 方法二alter table 表名 alter column 字段名 drop default;示例：alter table student alter column gender drop default;\n\n2.6 检查约束检查约束（CHECK）通过在 check 后面添加限定条件表达式实现对插入数据的检查，在更新表数据的时候，系统会检查更新后的数据行是否满足 CHECK 约束中的限定条件，可以分别对列或表实施 CHECK 约束。\n添加检查约束：\n-- 创建表时添加约束字段名 数据类型 check(限定条件表达式);-- 创建表后添加约束-- 方法一alter table 表名 modify column 字段名 数据类型 check(限定条件表达式);-- 方法二alter table 表名 add check(限定条件表达式);示例：-- 创建表时添加约束-- 方法一create table student (name varchar(20),age varchar(20) check(age &gt; 0 and age &lt; 120));-- 方法二，表级检查约束，可同时对表中多个字段进行限制，限制条件间用 and 连接create table student (id int,name varchar(20),age varchar(20)check(id &gt; 0 and age &gt; 0 and age &lt; 120 ));-- 创建表后添加约束-- 方法一alter table student modify column age varchar(20) check(age &gt; 0 and age &lt; 120);-- 方法二alter table student add check(age &gt; 0 and age &lt; 120);\n\n删除检查约束：\nalter table 表名 drop check 检查约束名;示例：alter table student drop check student_chk_1;\n\n2.7 外键约束外键约束（FOREIGN KEY）用来在两个表的数据之间建立关联，可以是一列或者多列，一个表可以有一个或多个外键。\n添加外键约束：\n-- 创建表时添加约束constraint 外键名 foreign key (从表外键字段) references 主表 (主键字段)-- 创建表后添加约束alter table 从表名 add constraint 外键名 foreign key (从表外键字段) references 主表 (主键字段);示例：-- 创建主表student，从表class，使class表的 studentid 字段作为外键关联 student 表的id字段-- 创建表时添加约束create table class (classid int primary key,studentid intconstraint fk_class_studentid foreign key (studentid) references student(id));-- 创建表后添加约束alter table class add constraint fk_class_studentid foreign key (studentid) references student(id);\n\n删除外键约束：\nalter table 从表名 drop foreign key 外键名;示例：alter table class drop foreign key fk_class_studentid;\n\n2.7.1 外键删除&#x2F;更新行为建立外键是为了保证数据的完整性和一致性，如果主表中的数据被删除或修改，从表中对应的数据也会发生相应变化，这些变化就由外键删除&#x2F;更新行为控制，可以在创建外键时定义其删除&#x2F;更新行为，如果未特定定义，默认值为 RESTRICT，其具体内容如下：\n\n\n\n行为\n说明\n\n\n\nNO ACTION &#x2F; RESTRICT\n当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新\n\n\nCASCADE\n当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有也删除&#x2F;更新外键在子表中的记录\n\n\nSET NULL\n当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null）\n\n\nSET DEFAULT\n父表有变更时，子表将外键设为一个默认值（Innodb不支持）\n\n\n添加外键删除&#x2F;更新行为：\nalter table 从表名 add constraint 外键名 foreign key (从表外键字段) references 主表 (主键字段) on update 更新行为 on delete 删除行为;例如：alter table class add constraint fk_class_studentid foreign key (studentid) references student(id) on update cascade on delete set null;\n\n2.7.2 外键约束注意事项\n从表里的外键通常是主表的主键；\n从表里外键的数据类型必须与主表中主键的数据类型一致；\n主表发生变化时应注意主表与从表的数据一致性问题；\n\n","categories":["MySQL学习笔记"],"tags":["MySQL","学习笔记"]}]